{"version":3,"file":"browser.js","sources":["../node_modules/@emmetio/scanner/scanner.es.js","../node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../src/lib/config.ts","../node_modules/@emmetio/html-matcher/dist/html-matcher.es.js","../node_modules/@emmetio/css-matcher/dist/css-matcher.es.js","../node_modules/emmet/dist/emmet.es.js","../node_modules/@emmetio/action-utils/dist/action-utils.es.js","../src/lib/utils.ts","../src/lib/syntax.ts","../node_modules/@emmetio/math-expression/dist/math.es.js","../src/lib/output.ts","../src/lib/emmet.ts","../src/abbreviation.ts","../src/lib/match-tags.ts","../src/mode/utils.ts","../src/mode/markup.ts","../src/mode/stylesheet.ts","../src/mode/snippet.ts","../src/commands/expand-abbreviation.ts","../src/commands/reset-abbreviation.ts","../src/commands/capture-abbreviation.ts","../src/commands/enter-abbreviation.ts","../src/commands/insert-line-break.ts","../src/commands/wrap-with-abbreviation.ts","../src/commands/balance.ts","../src/commands/comment.ts","../src/commands/evaluate-math.ts","../src/commands/go-to-edit-point.ts","../src/commands/go-to-tag-pair.ts","../src/commands/inc-dec-number.ts","../src/commands/remove-tag.ts","../src/commands/select-item.ts","../src/commands/split-join-tag.ts","../src/extension.ts","../src/browser.ts"],"sourcesContent":["const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { isAlphaNumericWord, isSpace, isQuote as isQuote$1, isNumber, isAlpha, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace() {\n        return ' ';\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                textInserted = true;\n                const value = Array.isArray(options.text)\n                    ? (pos != null ? options.text[pos] : options.text.join('\\n'))\n                    : options.text;\n                return value != null ? value : '';\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.text.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parseAbbreviation;\nexport { convert, getToken, abbreviation as parse, tokenize };\n//# sourceMappingURL=abbreviation.es.js.map\n","import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, short);\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume(scanner, isWhiteSpace);\n    }\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parse;\nexport { getToken, parser, tokenize };\n","import { GlobalConfig } from 'emmet';\n\nexport interface EmmetEditorOptions extends CodeMirror.EditorConfiguration {\n    emmet: EmmetConfig;\n}\n\nexport type EnableForSyntax = boolean | string[];\n\nexport interface EmmetConfig {\n    /** Enables abbreviation marking in editor. Works in known syntaxes only */\n    mark: EnableForSyntax;\n\n    /**\n     * Enables preview of marked abbreviation. Pass `true` to enable preview for\n     * all syntaxes or array of modes or Emmet syntax types (`markup` or `stylesheet`)\n     * where preview should be displayed\n     */\n    preview: EnableForSyntax;\n\n    /** Mark HTML tag pairs in editor */\n    markTagPairs: boolean;\n\n    /**\n     * Displays open tag preview when caret is inside its matching closing tag.\n     * Preview is displayed only if open tag has attributes.\n     * Works only if `markTagPairs` is enabled\n     */\n    previewOpenTag: boolean;\n\n    /** Allow automatic tag pair rename, works only if `markTagPairs` is enabled */\n    autoRenameTags: boolean;\n\n    /** Quotes to use in generated HTML attribute values */\n    attributeQuotes: 'single' | 'double';\n\n    /** Style for self-closing elements (like `<br>`) and boolean attributes */\n    markupStyle: 'html' | 'xhtml' | 'xml',\n\n    /**\n     * Enable automatic tag commenting. When enabled, elements generated from Emmet\n     * abbreviation with `id` and/or `class` attributes will receive a comment\n     * with these attribute values\n     */\n    comments: boolean;\n\n    /**\n     * Commenting template. Default value is `\\n<!-- /[#ID][.CLASS] -->`\n     * Outputs everything between `[` and `]` only if specified attribute name\n     * (written in UPPERCASE) exists in element. Attribute name is replaced with\n     * actual value. Use `\\n` to add a newline.\n     */\n    commentsTemplate?: string;\n\n    /**\n     * Enable BEM support. When enabled, Emmet will treat class names starting\n     * with `-` as _element_ and with `_` as _modifier_ in BEM notation.\n     * These class names will inherit `block` name from current or ancestor element.\n     * For example, the abbreviation `ul.nav.nav_secondary>li.nav__item` can be\n     * shortened to `ul.nav._secondary>li.-item` with this option enabled.\n     */\n    bem: boolean;\n\n    /**\n     * For stylesheet abbreviations, generate short HEX color values, if possible.\n     * For example, `c#0` will be expanded to `color: #000;` instead of `color: #000000`.\n     */\n    shortHex?: boolean;\n\n    /** Advanced Emmet config */\n    config?: GlobalConfig;\n\n    /**\n     * Function for attaching abbreviation preview\n     */\n    attachPreview?: (editor: CodeMirror.Editor, preview: HTMLElement, pos: CodeMirror.Position) => void;\n}\n\nexport const defaultConfig: EmmetConfig = {\n    mark: true,\n    preview: true,\n    autoRenameTags: true,\n    markTagPairs: true,\n    previewOpenTag: false,\n    attributeQuotes: 'double',\n    markupStyle: 'html',\n    comments: false,\n    commentsTemplate: '<!-- /[#ID][.CLASS] -->',\n    bem: false\n};\n\nexport default function getEmmetConfig(editor: CodeMirror.Editor, opt?: Partial<EmmetConfig>): EmmetConfig {\n    if (!opt) {\n        // @ts-ignore Bypass limited options, defined in typings\n        opt = editor.getOption('emmet');\n    }\n    return { ...defaultConfig, ...opt };\n}\n","import Scanner, { eatPair, isAlpha, isNumber, isQuote, isSpace, eatQuoted } from '@emmetio/scanner';\n\nconst defaultOptions = {\n    xml: false,\n    allTokens: false,\n    special: {\n        style: null,\n        script: ['', 'text/javascript', 'application/x-javascript', 'javascript', 'typescript', 'ts', 'coffee', 'coffeescript']\n    },\n    empty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr', 'col', 'embed', 'input', 'param', 'source', 'track']\n};\n/** Options for `Scanner` utils */\nconst opt = { throws: false };\nfunction createOptions(options = {}) {\n    return Object.assign(Object.assign({}, defaultOptions), options);\n}\n/**\n * Converts given string into array of character codes\n */\nfunction toCharCodes(str) {\n    return str.split('').map(ch => ch.charCodeAt(0));\n}\n/**\n * Consumes array of character codes from given scanner\n */\nfunction consumeArray(scanner, codes) {\n    const start = scanner.pos;\n    for (let i = 0; i < codes.length; i++) {\n        if (!scanner.eat(codes[i])) {\n            scanner.pos = start;\n            return false;\n        }\n    }\n    scanner.start = start;\n    return true;\n}\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @return Returns `true` if section was consumed\n */\nfunction consumeSection(scanner, open, close, allowUnclosed) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, open)) {\n        // consumed `<!--`, read next until we find ending part or reach the end of input\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, close)) {\n                scanner.start = start;\n                return true;\n            }\n            scanner.pos++;\n        }\n        // unclosed section is allowed\n        if (allowUnclosed) {\n            scanner.start = start;\n            return true;\n        }\n        scanner.pos = start;\n        return false;\n    }\n    // unable to find section, revert to initial position\n    scanner.pos = start;\n    return false;\n}\n/**\n * Check if given character can be used as a start of tag name or attribute\n */\nfunction nameStartChar(ch) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameStartChar\n    return isAlpha(ch) || ch === 58 /* Colon */ || ch === 95 /* Underscore */\n        || (ch >= 0xC0 && ch <= 0xD6)\n        || (ch >= 0xD8 && ch <= 0xF6)\n        || (ch >= 0xF8 && ch <= 0x2FF)\n        || (ch >= 0x370 && ch <= 0x37D)\n        || (ch >= 0x37F && ch <= 0x1FFF);\n}\n/**\n * Check if given character can be used in a tag or attribute name\n */\nfunction nameChar(ch) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameChar\n    return nameStartChar(ch) || ch === 45 /* Dash */ || ch === 46 /* Dot */ || isNumber(ch)\n        || ch === 0xB7\n        || (ch >= 0x0300 && ch <= 0x036F);\n}\n/**\n * Consumes identifier from given scanner\n */\nfunction ident(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(nameStartChar)) {\n        scanner.eatWhile(nameChar);\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Check if given code is tag terminator\n */\nfunction isTerminator(code) {\n    return code === 62 /* RightAngle */ || code === 47 /* Slash */;\n}\n/**\n * Check if given character code is valid unquoted value\n */\nfunction isUnquoted(code) {\n    return !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);\n}\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @return `true` if paired token was consumed\n */\nfunction consumePaired(scanner) {\n    return eatPair(scanner, 60 /* LeftAngle */, 62 /* RightAngle */, opt)\n        || eatPair(scanner, 40 /* LeftRound */, 41 /* RightRound */, opt)\n        || eatPair(scanner, 91 /* LeftSquare */, 93 /* RightSquare */, opt)\n        || eatPair(scanner, 123 /* LeftCurly */, 125 /* RightCurly */, opt);\n}\n/**\n * Returns unquoted value of given string\n */\nfunction getUnquotedValue(value) {\n    // Trim quotes\n    if (isQuote(value.charCodeAt(0))) {\n        value = value.slice(1);\n    }\n    if (isQuote(value.charCodeAt(value.length - 1))) {\n        value = value.slice(0, -1);\n    }\n    return value;\n}\n\n/**\n * Parses given string as list of HTML attributes.\n * @param src A fragment to parse. If `name` argument is provided, it must be an\n * opening tag (`<a foo=\"bar\">`), otherwise it should be a fragment between element\n * name and tag closing angle (`foo=\"bar\"`)\n * @param name Tag name\n */\nfunction attributes(src, name) {\n    const result = [];\n    let start = 0;\n    let end = src.length;\n    if (name) {\n        start = name.length + 1;\n        end -= src.slice(-2) === '/>' ? 2 : 1;\n    }\n    const scanner = new Scanner(src, start, end);\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            const token = {\n                name: scanner.current(),\n                nameStart: scanner.start,\n                nameEnd: scanner.pos\n            };\n            if (scanner.eat(61 /* Equals */) && attributeValue(scanner)) {\n                token.value = scanner.current();\n                token.valueStart = scanner.start;\n                token.valueEnd = scanner.pos;\n            }\n            result.push(token);\n        }\n        else {\n            // Do not break on invalid attributes: we are not validating parser\n            scanner.pos++;\n        }\n    }\n    return result;\n}\n/**\n * Consumes attribute name from given scanner context\n */\nfunction attributeName(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */) || scanner.eat(35 /* Hash */)) {\n        // Angular-style directives: `<section *ngIf=\"showSection\">`, `<video #movieplayer ...>`\n        ident(scanner);\n        scanner.start = start;\n        return true;\n    }\n    // Attribute name could be a regular name or expression:\n    // React-style – `<div {...props}>`\n    // Angular-style – `<div [ng-for]>` or `<div *ng-for>`\n    return consumePaired(scanner) || ident(scanner);\n}\n/**\n * Consumes attribute value\n */\nfunction attributeValue(scanner) {\n    // Supported attribute values are quoted, React-like expressions (`{foo}`)\n    // or unquoted literals\n    return eatQuoted(scanner, opt) || consumePaired(scanner) || unquoted(scanner);\n}\n/**\n * Returns clean (unquoted) value of `name` attribute\n */\nfunction getAttributeValue(attrs, name) {\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (attr.name === name) {\n            return attr.value && getUnquotedValue(attr.value);\n        }\n    }\n}\n/**\n * Consumes unquoted value\n */\nfunction unquoted(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isUnquoted)) {\n        scanner.start = start;\n        return true;\n    }\n}\n\nconst cdataOpen = toCharCodes('<![CDATA[');\nconst cdataClose = toCharCodes(']]>');\nconst commentOpen = toCharCodes('<!--');\nconst commentClose = toCharCodes('-->');\nconst piStart = toCharCodes('<?');\nconst piEnd = toCharCodes('?>');\nconst erbStart = toCharCodes('<%');\nconst erbEnd = toCharCodes('%>');\n/**\n * Performs fast scan of given source code: for each tag found it invokes callback\n * with tag name, its type (open, close, self-close) and range in original source.\n * Unlike regular scanner, fast scanner doesn’t provide info about attributes to\n * reduce object allocations hence increase performance.\n * If `callback` returns `false`, scanner stops parsing.\n * @param special List of “special” HTML tags which should be ignored. Most likely\n * it’s a \"script\" and \"style\" tags.\n */\nfunction scan(source, callback, options) {\n    const scanner = new Scanner(source);\n    const special = options ? options.special : null;\n    const allTokens = options ? options.allTokens : false;\n    let type;\n    let name;\n    let nameStart;\n    let nameEnd;\n    let nameCodes;\n    let found = false;\n    let piName = null;\n    while (!scanner.eof()) {\n        const start = scanner.pos;\n        if (cdata(scanner)) {\n            if (allTokens && callback('#cdata', 4 /* CData */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (comment(scanner)) {\n            if (allTokens && callback('#comment', 6 /* Comment */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (erb(scanner)) {\n            if (allTokens && callback('#erb', 7 /* ERB */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (piName = processingInstruction(scanner)) {\n            if (allTokens && callback(piName, 5 /* ProcessingInstruction */, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        }\n        else if (scanner.eat(60 /* LeftAngle */)) {\n            // Maybe a tag name?\n            type = scanner.eat(47 /* Slash */) ? 2 /* Close */ : 1 /* Open */;\n            nameStart = scanner.pos;\n            if (ident(scanner)) {\n                // Consumed tag name\n                nameEnd = scanner.pos;\n                if (type !== 2 /* Close */) {\n                    skipAttributes(scanner);\n                    scanner.eatWhile(isSpace);\n                    if (scanner.eat(47 /* Slash */)) {\n                        type = 3 /* SelfClose */;\n                    }\n                }\n                if (scanner.eat(62 /* RightAngle */)) {\n                    // Tag properly closed\n                    name = scanner.substring(nameStart, nameEnd);\n                    if (callback(name, type, start, scanner.pos) === false) {\n                        break;\n                    }\n                    if (type === 1 /* Open */ && special && isSpecial(special, name, source, start, scanner.pos)) {\n                        // Found opening tag of special element: we should skip\n                        // scanner contents until we find closing tag\n                        nameCodes = toCharCodes(name);\n                        found = false;\n                        while (!scanner.eof()) {\n                            if (consumeClosing(scanner, nameCodes)) {\n                                found = true;\n                                break;\n                            }\n                            scanner.pos++;\n                        }\n                        if (found && callback(name, 2 /* Close */, scanner.start, scanner.pos) === false) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Skips attributes in current tag context\n */\nfunction skipAttributes(scanner) {\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            if (scanner.eat(61 /* Equals */)) {\n                attributeValue(scanner);\n            }\n        }\n        else if (isTerminator(scanner.peek())) {\n            break;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n}\n/**\n * Consumes closing tag with given name from scanner\n */\nfunction consumeClosing(scanner, name) {\n    const start = scanner.pos;\n    if (scanner.eat(60 /* LeftAngle */) && scanner.eat(47 /* Slash */) && consumeArray(scanner, name) && scanner.eat(62 /* RightAngle */)) {\n        scanner.start = start;\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes CDATA from given scanner\n */\nfunction cdata(scanner) {\n    return consumeSection(scanner, cdataOpen, cdataClose, true);\n}\n/**\n * Consumes comments from given scanner\n */\nfunction comment(scanner) {\n    return consumeSection(scanner, commentOpen, commentClose, true);\n}\n/**\n * Consumes processing instruction from given scanner. If consumed, returns\n * processing instruction name\n */\nfunction processingInstruction(scanner) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, piStart) && ident(scanner)) {\n        const name = scanner.current();\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, piEnd)) {\n                break;\n            }\n            eatQuoted(scanner) || scanner.pos++;\n        }\n        scanner.start = start;\n        return name;\n    }\n    scanner.pos = start;\n    return null;\n}\n/**\n * Consumes ERB-style entity: `<% ... %>` or `<%= ... %>`\n */\nfunction erb(scanner) {\n    const start = scanner.pos;\n    if (consumeArray(scanner, erbStart)) {\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, erbEnd)) {\n                break;\n            }\n            eatQuoted(scanner) || scanner.pos++;\n        }\n        scanner.start = start;\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Check if given tag name should be considered as special\n */\nfunction isSpecial(special, name, source, start, end) {\n    if (name in special) {\n        const typeValues = special[name];\n        if (!Array.isArray(typeValues)) {\n            return true;\n        }\n        const attrs = attributes(source.substring(start + name.length + 1, end - 1));\n        return typeValues.includes(getAttributeValue(attrs, 'type') || '');\n    }\n    return false;\n}\n\n/**\n * Finds matched tag for given `pos` location in XML/HTML `source`\n */\nfunction match(source, pos, opt) {\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    let result = null;\n    scan(source, (name, type, start, end) => {\n        if (type === 1 /* Open */ && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = 3 /* SelfClose */;\n        }\n        if (type === 1 /* Open */) {\n            // Allocate tag object from pool\n            stack.push(allocTag(pool, name, start, end));\n        }\n        else if (type === 3 /* SelfClose */) {\n            if (start < pos && pos < end) {\n                // Matched given self-closing tag\n                result = {\n                    name,\n                    attributes: getAttributes(source, start, end, name),\n                    open: [start, end]\n                };\n                return false;\n            }\n        }\n        else {\n            const tag = last(stack);\n            if (tag && tag.name === name) {\n                // Matching closing tag found\n                if (tag.start < pos && pos < end) {\n                    result = {\n                        name,\n                        attributes: getAttributes(source, tag.start, tag.end, name),\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    };\n                    return false;\n                }\n                else if (stack.length) {\n                    // Release tag object for further re-use\n                    releaseTag(pool, stack.pop());\n                }\n            }\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in outward direction\n */\nfunction balancedOutward(source, pos, opt) {\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    const result = [];\n    scan(source, (name, type, start, end) => {\n        if (type === 2 /* Close */) {\n            const tag = last(stack);\n            if (tag && tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.start < pos && pos < end) {\n                    result.push({\n                        name,\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    });\n                }\n                // Release tag object for further re-use\n                releaseTag(pool, stack.pop());\n            }\n        }\n        else if (type === 3 /* SelfClose */ || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag\n                result.push({ name, open: [start, end] });\n            }\n        }\n        else {\n            stack.push(allocTag(pool, name, start, end));\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in inward direction\n */\nfunction balancedInward(source, pos, opt) {\n    // Collecting tags for inward balancing is a bit trickier: we have to store\n    // first child of every matched tag until we find the one that matches given\n    // location\n    const pool = [];\n    const stack = [];\n    const options = createOptions(opt);\n    const result = [];\n    const alloc = (name, start, end) => {\n        if (pool.length) {\n            const tag = pool.pop();\n            tag.name = name;\n            tag.ranges.push(start, end);\n            return tag;\n        }\n        return { name, ranges: [start, end] };\n    };\n    const release = (tag) => {\n        tag.ranges.length = 0;\n        tag.firstChild = void 0;\n        pool.push(tag);\n    };\n    scan(source, (name, type, start, end) => {\n        if (type === 2 /* Close */) {\n            if (!stack.length) {\n                // Some sort of lone closing tag, ignore it\n                return;\n            }\n            let tag = last(stack);\n            if (tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.ranges[0] <= pos && pos <= end) {\n                    result.push({\n                        name,\n                        open: tag.ranges.slice(0, 2),\n                        close: [start, end]\n                    });\n                    while (tag.firstChild) {\n                        const child = tag.firstChild;\n                        const res = {\n                            name: child.name,\n                            open: child.ranges.slice(0, 2)\n                        };\n                        if (child.ranges.length > 2) {\n                            res.close = child.ranges.slice(2, 4);\n                        }\n                        result.push(res);\n                        release(tag);\n                        tag = child;\n                    }\n                    return false;\n                }\n                else {\n                    stack.pop();\n                    const parent = last(stack);\n                    if (parent && !parent.firstChild) {\n                        // No first child in parent node: store current tag\n                        tag.ranges.push(start, end);\n                        parent.firstChild = tag;\n                    }\n                    else {\n                        release(tag);\n                    }\n                }\n            }\n        }\n        else if (type === 3 /* SelfClose */ || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag, no need to look further\n                result.push({ name, open: [start, end] });\n                return false;\n            }\n            const parent = last(stack);\n            if (parent && !parent.firstChild) {\n                parent.firstChild = alloc(name, start, end);\n            }\n        }\n        else {\n            stack.push(alloc(name, start, end));\n        }\n    }, options);\n    stack.length = pool.length = 0;\n    return result;\n}\nfunction allocTag(pool, name, start, end) {\n    if (pool.length) {\n        const tag = pool.pop();\n        tag.name = name;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, start, end };\n}\nfunction releaseTag(pool, tag) {\n    pool.push(tag);\n}\n/**\n * Returns parsed attributes from given source\n */\nfunction getAttributes(source, start, end, name) {\n    const tokens = attributes(source.slice(start, end), name);\n    tokens.forEach(attr => {\n        attr.nameStart += start;\n        attr.nameEnd += start;\n        if (attr.value != null) {\n            attr.valueStart += start;\n            attr.valueEnd += start;\n        }\n    });\n    return tokens;\n}\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name, options) {\n    return !options.xml && options.empty.includes(name);\n}\nfunction last(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\nexport default match;\nexport { attributes, balancedInward, balancedOutward, createOptions, scan };\n//# sourceMappingURL=html-matcher.es.js.map\n","import Scanner, { isSpace, isQuote } from '@emmetio/scanner';\n\n/**\n * Performs fast scan of given stylesheet (CSS, LESS, SCSS) source code and runs\n * callback for each token and its range found. The goal of this parser is to quickly\n * determine document structure: selector, property, value and block end.\n * It doesn’t provide detailed info about CSS atoms like compound selectors,\n * operators, quoted string etc. to reduce memory allocations: this data can be\n * parsed later on demand.\n */\nfunction scan(source, callback) {\n    const scanner = new Scanner(source);\n    const state = {\n        start: -1,\n        end: -1,\n        propertyStart: -1,\n        propertyEnd: -1,\n        propertyDelimiter: -1,\n        expression: 0,\n    };\n    let blockEnd;\n    const notify = (type, delimiter = scanner.start, start = state.start, end = state.end) => {\n        return callback(type, start, end, delimiter) === false;\n    };\n    while (!scanner.eof()) {\n        if (comment(scanner) || whitespace(scanner)) {\n            continue;\n        }\n        scanner.start = scanner.pos;\n        if ((blockEnd = scanner.eat(125 /* RightCurly */)) || scanner.eat(59 /* Semicolon */)) {\n            // Block or property end\n            if (state.propertyStart !== -1) {\n                // We have pending property\n                if (notify(\"propertyName\" /* PropertyName */, state.propertyDelimiter, state.propertyStart, state.propertyEnd)) {\n                    return;\n                }\n                if (state.start === -1) {\n                    // Explicit property value state: emit empty value\n                    state.start = state.end = scanner.start;\n                }\n                if (notify(\"propertyValue\" /* PropertyValue */)) {\n                    return;\n                }\n            }\n            else if (state.start !== -1 && notify(\"propertyName\" /* PropertyName */)) {\n                // Flush consumed token\n                return;\n            }\n            if (blockEnd) {\n                state.start = scanner.start;\n                state.end = scanner.pos;\n                if (notify(\"blockEnd\" /* BlockEnd */)) {\n                    return;\n                }\n            }\n            reset(state);\n        }\n        else if (scanner.eat(123 /* LeftCurly */)) {\n            // Block start\n            if (state.start === -1 && state.propertyStart === -1) {\n                // No consumed selector, emit empty value as selector start\n                state.start = state.end = scanner.pos;\n            }\n            if (state.propertyStart !== -1) {\n                // Now we know that value that looks like property name-value pair\n                // was actually a selector\n                state.start = state.propertyStart;\n            }\n            if (notify(\"selector\" /* Selector */)) {\n                return;\n            }\n            reset(state);\n        }\n        else if (scanner.eat(58 /* Colon */) && !isKnownSelectorColon(scanner, state)) {\n            // Colon could be one of the following:\n            // — property delimiter: `foo: bar`, must be in block context\n            // — variable delimiter: `$foo: bar`, could be anywhere\n            // — pseudo-selector: `a:hover`, could be anywhere (for LESS and SCSS)\n            // — media query expression: `min-width: 100px`, must be inside expression context\n            // Since I can’t easily detect `:` meaning for sure, we’ll update state\n            // to accumulate possible property name-value pair or selector\n            if (state.propertyStart === -1) {\n                state.propertyStart = state.start;\n            }\n            state.propertyEnd = state.end;\n            state.propertyDelimiter = scanner.pos - 1;\n            state.start = state.end = -1;\n        }\n        else {\n            if (state.start === -1) {\n                state.start = scanner.pos;\n            }\n            if (scanner.eat(40 /* LeftRound */)) {\n                state.expression++;\n            }\n            else if (scanner.eat(41 /* RightRound */)) {\n                state.expression--;\n            }\n            else if (!literal(scanner)) {\n                scanner.pos++;\n            }\n            state.end = scanner.pos;\n        }\n    }\n    if (state.propertyStart !== -1) {\n        // Pending property name\n        if (notify(\"propertyName\" /* PropertyName */, state.propertyDelimiter, state.propertyStart, state.propertyEnd)) {\n            return;\n        }\n    }\n    if (state.start !== -1) {\n        // There’s pending token in state\n        notify(state.propertyStart !== -1 ? \"propertyValue\" /* PropertyValue */ : \"propertyName\" /* PropertyName */, -1);\n    }\n}\nfunction whitespace(scanner) {\n    return scanner.eatWhile(isSpace);\n}\n/**\n * Consumes CSS comments from scanner: `/*  * /`\n * It’s possible that comment may not have closing part\n */\nfunction comment(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(47 /* Slash */) && scanner.eat(42 /* Asterisk */)) {\n        scanner.start = start;\n        while (!scanner.eof()) {\n            if (scanner.eat(42 /* Asterisk */)) {\n                if (scanner.eat(47 /* Slash */)) {\n                    return true;\n                }\n                continue;\n            }\n            scanner.pos++;\n        }\n        return true;\n    }\n    else {\n        scanner.pos = start;\n    }\n    return false;\n}\n/**\n * Consumes single- or double-quoted string literal\n */\nfunction literal(scanner) {\n    const ch = scanner.peek();\n    if (isQuote(ch)) {\n        scanner.start = scanner.pos++;\n        while (!scanner.eof()) {\n            if (scanner.eat(ch) || scanner.eat(10 /* LF */) || scanner.eat(13 /* CR */)) {\n                break;\n            }\n            // Skip escape character, if any\n            scanner.eat(92 /* Backslash */);\n            scanner.pos++;\n        }\n        // Do not throw if string is incomplete\n        return true;\n    }\n}\nfunction reset(state) {\n    state.start = state.end = state.propertyStart = state.propertyEnd = state.propertyDelimiter = -1;\n}\n/**\n * Check if current state is a known selector context for `:` delimiter\n */\nfunction isKnownSelectorColon(scanner, state) {\n    // Either inside expression like `(min-width: 10px)` or pseudo-element `::before`\n    return state.expression || scanner.eatWhile(58 /* Colon */);\n}\n\n// NB: no `Minus` operator, it must be handled differently\nconst operators = [\n    43 /* Plus */, 47 /* Division */, 42 /* Multiplication */,\n    44 /* Comma */\n];\n/**\n * Splits given CSS value into token list\n */\nfunction splitValue(value, offset = 0) {\n    let start = -1;\n    let expression = 0;\n    let pos = 0;\n    const result = [];\n    const scanner = new Scanner(value);\n    while (!scanner.eof()) {\n        pos = scanner.pos;\n        if (scanner.eat(isSpace) || scanner.eat(isOperator) || isMinusOperator(scanner)) {\n            // Use space as value delimiter but only if not in expression context,\n            // e.g. `1 2` are distinct values but `(1 2)` not\n            if (!expression && start !== -1) {\n                result.push([offset + start, offset + pos]);\n                start = -1;\n            }\n            scanner.eatWhile(isSpace);\n        }\n        else {\n            if (start === -1) {\n                start = scanner.pos;\n            }\n            if (scanner.eat(40 /* LeftRound */)) {\n                expression++;\n            }\n            else if (scanner.eat(41 /* RightRound */)) {\n                expression--;\n            }\n            else if (!literal(scanner)) {\n                scanner.pos++;\n            }\n        }\n    }\n    if (start !== -1 && start !== scanner.pos) {\n        result.push([offset + start, offset + scanner.pos]);\n    }\n    return result;\n}\nfunction isOperator(ch) {\n    return operators.includes(ch);\n}\n/**\n * Check if current scanner state is at minus operator\n */\nfunction isMinusOperator(scanner) {\n    // Minus operator is tricky since CSS supports dashes in keyword names like\n    // `no-repeat`\n    const start = scanner.pos;\n    if (scanner.eat(45 /* Minus */) && scanner.eat(isSpace)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n\nfunction match(source, pos) {\n    const pool = [];\n    const stack = [];\n    let result = null;\n    let pendingProperty = null;\n    const releasePending = () => {\n        if (pendingProperty) {\n            releaseRange(pool, pendingProperty);\n            pendingProperty = null;\n        }\n    };\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            releasePending();\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            releasePending();\n            const parent = stack.pop();\n            if (parent && parent[0] < pos && pos < end) {\n                result = {\n                    type: 'selector',\n                    start: parent[0],\n                    end,\n                    bodyStart: parent[2] + 1,\n                    bodyEnd: start\n                };\n                return false;\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            releasePending();\n            pendingProperty = allocRange(pool, start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (pendingProperty && pendingProperty[0] < pos && pos < end) {\n                result = {\n                    type: 'property',\n                    start: pendingProperty[0],\n                    end: delimiter + 1,\n                    bodyStart: start,\n                    bodyEnd: end\n                };\n                return false;\n            }\n            releasePending();\n        }\n    });\n    return result;\n}\n/**\n * Returns balanced CSS model: a list of all ranges that could possibly match\n * given location when moving in outward direction\n */\nfunction balancedOutward(source, pos) {\n    const pool = [];\n    const stack = [];\n    const result = [];\n    let property = null;\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            const left = stack.pop();\n            if (left && left[0] < pos && end > pos) {\n                // Matching section found\n                const inner = innerRange(source, left[2] + 1, start);\n                inner && push(result, inner);\n                push(result, [left[0], end]);\n            }\n            left && releaseRange(pool, left);\n            if (!stack.length) {\n                return false;\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            property && releaseRange(pool, property);\n            property = allocRange(pool, start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (property && property[0] < pos && Math.max(delimiter, end) > pos) {\n                // Push full token and value range\n                push(result, [start, end]);\n                push(result, [property[0], delimiter !== -1 ? delimiter + 1 : end]);\n            }\n        }\n        if (type !== \"propertyName\" /* PropertyName */ && property) {\n            releaseRange(pool, property);\n            property = null;\n        }\n    });\n    return result;\n}\n/**\n * Returns balanced CSS selectors: a list of all ranges that could possibly match\n * given location when moving in inward direction\n */\nfunction balancedInward(source, pos) {\n    // Collecting ranges for inward balancing is a bit trickier: we have to store\n    // first child of every matched selector until we find the one that matches given\n    // location\n    const pool = [];\n    const stack = [];\n    const result = [];\n    let pendingProperty = null;\n    const alloc = (start, end, delimiter) => {\n        if (pool.length) {\n            const range = pool.pop();\n            range.start = start;\n            range.end = end;\n            range.delimiter = delimiter;\n            return range;\n        }\n        return { start, end, delimiter, firstChild: null };\n    };\n    const release = (range) => {\n        range.firstChild = null;\n        pool.push(range);\n    };\n    const releasePending = () => {\n        if (pendingProperty) {\n            release(pendingProperty);\n            pendingProperty = null;\n        }\n    };\n    /**\n     * Pushes given inward range as a first child of current selector only if it’s\n     * not set yet\n     */\n    const pushChild = (start, end, delimiter) => {\n        const parent = last(stack);\n        if (parent && !parent.firstChild) {\n            parent.firstChild = alloc(start, end, delimiter);\n        }\n    };\n    scan(source, (type, start, end, delimiter) => {\n        if (type === \"blockEnd\" /* BlockEnd */) {\n            releasePending();\n            let range = stack.pop();\n            if (!range) {\n                // Some sort of lone closing brace, ignore it\n                return;\n            }\n            if (range.start <= pos && pos <= end) {\n                // Matching selector found: add it and its inner range into result\n                let inner = innerRange(source, range.delimiter + 1, start);\n                push(result, [range.start, end]);\n                inner && push(result, inner);\n                while (range.firstChild) {\n                    const child = range.firstChild;\n                    inner = innerRange(source, child.delimiter + 1, child.end - 1);\n                    push(result, [child.start, child.end]);\n                    inner && push(result, inner);\n                    range = child;\n                }\n                return false;\n            }\n            else {\n                const parent = last(stack);\n                if (parent && !parent.firstChild) {\n                    // No first child in parent node: store current selector\n                    range.end = end;\n                    parent.firstChild = range;\n                }\n                else {\n                    release(range);\n                }\n            }\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            releasePending();\n            pendingProperty = alloc(start, end, delimiter);\n            pushChild(start, end, delimiter);\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            if (pendingProperty) {\n                if (pendingProperty.start <= pos && end >= pos) {\n                    // Direct hit into property, no need to look further\n                    push(result, [pendingProperty.start, delimiter + 1]);\n                    push(result, [start, end]);\n                    releasePending();\n                    return false;\n                }\n                const parent = last(stack);\n                if (parent && parent.firstChild && parent.firstChild.start === pendingProperty.start) {\n                    // First child is an expected property name, update its range\n                    // to include property value\n                    parent.firstChild.end = delimiter !== -1 ? delimiter + 1 : end;\n                }\n                releasePending();\n            }\n        }\n        else {\n            // Selector start\n            stack.push(alloc(start, end, delimiter));\n            releasePending();\n        }\n    });\n    stack.length = pool.length = 0;\n    return result;\n}\n/**\n * Returns inner range for given selector bounds: narrows it to first non-empty\n * region. If resulting region is empty, returns `null`\n */\nfunction innerRange(source, start, end) {\n    while (start < end && isSpace(source.charCodeAt(start))) {\n        start++;\n    }\n    while (end > start && isSpace(source.charCodeAt(end - 1))) {\n        end--;\n    }\n    return start !== end ? [start, end] : null;\n}\nfunction allocRange(pool, start, end, delimiter) {\n    if (pool.length) {\n        const range = pool.pop();\n        range[0] = start;\n        range[1] = end;\n        range[2] = delimiter;\n        return range;\n    }\n    return [start, end, delimiter];\n}\nfunction releaseRange(pool, range) {\n    range && pool.push(range);\n    return null;\n}\nfunction push(ranges, range) {\n    const prev = ranges.length ? ranges[ranges.length - 1] : null;\n    if ((!prev || prev[0] !== range[0] || prev[1] !== range[1]) && range[0] !== range[1]) {\n        ranges.push(range);\n    }\n}\nfunction last(arr) {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n\nexport default match;\nexport { balancedInward, balancedOutward, scan, splitValue };\n//# sourceMappingURL=css-matcher.es.js.map\n","import parse$2 from '@emmetio/abbreviation';\nexport { default as markupAbbreviation } from '@emmetio/abbreviation';\nimport parse$3 from '@emmetio/css-abbreviation';\nexport { default as stylesheetAbbreviation } from '@emmetio/css-abbreviation';\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parse$2(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        abbr = parse$2(abbr, parseOpt);\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$3(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$3(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${1});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:grid|inline-grid|subgrid|block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat()|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat()|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nexport default expandAbbreviation;\nexport { extractAbbreviation as extract, markup, parse as parseMarkup, parse$1 as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet };\n//# sourceMappingURL=emmet.es.js.map\n","import { scan, attributes, createOptions } from '@emmetio/html-matcher';\nimport { scan as scan$1, splitValue } from '@emmetio/css-matcher';\nimport expand, { stylesheetAbbreviation, markupAbbreviation } from 'emmet';\n\nconst pairs = {\n    '{': '}',\n    '[': ']',\n    '(': ')'\n};\nconst pairsEnd = [];\nfor (const key of Object.keys(pairs)) {\n    pairsEnd.push(pairs[key]);\n}\n/**\n * Returns `true` if given character code is a space\n */\nfunction isSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160 /* non-breaking space */\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\nfunction pushRange(ranges, range) {\n    const prev = ranges[ranges.length - 1];\n    if (range && range[0] !== range[1] && (!prev || prev[0] !== range[0] || prev[1] !== range[1])) {\n        ranges.push(range);\n    }\n}\n/**\n * Returns ranges of tokens in given value. Tokens are space-separated words.\n */\nfunction tokenList(value, offset = 0) {\n    const ranges = [];\n    const len = value.length;\n    let pos = 0;\n    let start = 0;\n    let end = 0;\n    while (pos < len) {\n        end = pos;\n        const ch = value.charCodeAt(pos++);\n        if (isSpace(ch)) {\n            if (start !== end) {\n                ranges.push([offset + start, offset + end]);\n            }\n            while (isSpace(value.charCodeAt(pos))) {\n                pos++;\n            }\n            start = pos;\n        }\n    }\n    if (start !== pos) {\n        ranges.push([offset + start, offset + pos]);\n    }\n    return ranges;\n}\n/**\n * Check if given character is a quote\n */\nfunction isQuote(ch) {\n    return ch === '\"' || ch === '\\'';\n}\n/**\n * Returns value of given attribute, parsed by Emmet HTML matcher\n */\nfunction attributeValue(attr) {\n    const { value } = attr;\n    return value && isQuoted(value)\n        ? value.slice(1, -1)\n        : value;\n}\nfunction attributeValueRange(tag, attr, offset = 0) {\n    let valueStart = attr.valueStart;\n    let valueEnd = attr.valueEnd;\n    if (isQuote(tag[valueStart])) {\n        valueStart++;\n    }\n    if (isQuote(tag[valueEnd - 1]) && valueEnd > valueStart) {\n        valueEnd--;\n    }\n    return [offset + valueStart, offset + valueEnd];\n}\n/**\n * Check if given value is either quoted or written as expression\n */\nfunction isQuoted(value) {\n    return !!value && (isQuotedString(value) || isExprString(value));\n}\n/**\n * Check if given string is quoted with single or double quotes\n */\nfunction isQuotedString(str) {\n    return str.length > 1 && isQuote(str[0]) && str[0] === str.slice(-1);\n}\n/**\n * Check if given string contains expression, e.g. wrapped with `{` and `}`\n */\nfunction isExprString(str) {\n    return str[0] === '{' && str.slice(-1) === '}';\n}\n/**\n * Returns last element of given array\n */\nfunction last(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\n/**\n * Check if there’s open or self-closing tag under given `pos` location in source code.\n * If found, returns its name, range in source and parsed attributes\n */\nfunction getOpenTag(code, pos) {\n    let tag = void 0;\n    // Find open or self-closing tag, closest to given position\n    scan(code, (name, type, start, end) => {\n        if (start < pos && end > pos) {\n            tag = { name, type, start, end };\n            if (type === 1 /* Open */ || type === 3 /* SelfClose */) {\n                tag.attributes = shiftAttributeRanges(attributes(code.slice(start, end), name), start);\n            }\n            return false;\n        }\n        if (end > pos) {\n            return false;\n        }\n    });\n    return tag;\n}\n/**\n * Returns list of matched tags in given source code\n */\nfunction getTagMatches(code, options) {\n    const opt = createOptions(options);\n    const stack = [];\n    const result = [];\n    scan(code, (name, type, start, end) => {\n        if (type === 3 /* SelfClose */) {\n            result.push({ name, open: [start, end] });\n        }\n        else if (type === 1 /* Open */) {\n            const item = { name, open: [start, end] };\n            stack.push(item);\n            result.push(item);\n        }\n        else {\n            // Handle closing tag\n            while (stack.length) {\n                const item = stack.pop();\n                if (item.name === name) {\n                    item.close = [start, end];\n                    break;\n                }\n            }\n        }\n    }, opt);\n    return result;\n}\n/**\n * Finds tag match for given position\n */\nfunction findTagMatch(source, pos, options) {\n    if (typeof source === 'string') {\n        source = getTagMatches(source, options);\n    }\n    let candidate;\n    source.some(match => {\n        const start = match.open[0];\n        const end = match.close ? match.close[1] : match.open[1];\n        if (pos < start) {\n            // All the following tags will be after given position, stop searching\n            return true;\n        }\n        if (pos > start && pos < end) {\n            candidate = match;\n        }\n    });\n    return candidate;\n}\n/**\n * Returns list of ranges for Select Next/Previous Item action\n */\nfunction selectItemHTML(code, pos, isPrev) {\n    return isPrev ? selectPreviousItem(code, pos) : selectNextItem(code, pos);\n}\n/**\n * Returns list of ranges for Select Next Item action\n */\nfunction selectNextItem(code, pos) {\n    let result = void 0;\n    // Find open or self-closing tag, closest to given position\n    scan(code, (name, type, start, end) => {\n        if ((type === 1 /* Open */ || type === 3 /* SelfClose */) && end > pos) {\n            // Found open or self-closing tag\n            result = getTagSelectionModel(code, name, start, end);\n            return false;\n        }\n    });\n    return result;\n}\n/**\n * Returns list of ranges for Select Previous Item action\n */\nfunction selectPreviousItem(code, pos) {\n    let lastType = null;\n    let lastName = '';\n    let lastStart = -1;\n    let lastEnd = -1;\n    // We should find the closest open or self-closing tag left to given `pos`.\n    scan(code, (name, type, start, end) => {\n        if (start >= pos) {\n            return false;\n        }\n        if (type === 1 /* Open */ || type === 3 /* SelfClose */) {\n            // Found open or self-closing tag\n            lastName = name;\n            lastType = type;\n            lastStart = start;\n            lastEnd = end;\n        }\n    });\n    if (lastType !== null) {\n        return getTagSelectionModel(code, lastName, lastStart, lastEnd);\n    }\n}\n/**\n * Parses open or self-closing tag in `start:end` range of `code` and returns its\n * model for selecting items\n * @param code Document source code\n * @param name Name of matched tag\n */\nfunction getTagSelectionModel(code, name, start, end) {\n    const ranges = [\n        // Add tag name range\n        [start + 1, start + 1 + name.length]\n    ];\n    // Parse and add attributes ranges\n    const tagSrc = code.slice(start, end);\n    for (const attr of attributes(tagSrc, name)) {\n        if (attr.value != null) {\n            // Attribute with value\n            pushRange(ranges, [start + attr.nameStart, start + attr.valueEnd]);\n            // Add (unquoted) value range\n            const val = valueRange(attr);\n            if (val[0] !== val[1]) {\n                pushRange(ranges, [start + val[0], start + val[1]]);\n                if (attr.name === 'class') {\n                    // For class names, split value into space-separated tokens\n                    const tokens = tokenList(tagSrc.slice(val[0], val[1]), start + val[0]);\n                    for (const token of tokens) {\n                        pushRange(ranges, token);\n                    }\n                }\n            }\n        }\n        else {\n            // Attribute without value (boolean)\n            pushRange(ranges, [start + attr.nameStart, start + attr.nameEnd]);\n        }\n    }\n    return { start, end, ranges };\n}\n/**\n * Returns value range of given attribute. Value range is unquoted.\n */\nfunction valueRange(attr) {\n    const value = attr.value;\n    const ch = value[0];\n    const lastCh = value[value.length - 1];\n    if (ch === '\"' || ch === '\\'') {\n        return [\n            attr.valueStart + 1,\n            attr.valueEnd - (lastCh === ch ? 1 : 0)\n        ];\n    }\n    if (ch === '{' && lastCh === '}') {\n        return [\n            attr.valueStart + 1,\n            attr.valueEnd - 1\n        ];\n    }\n    return [attr.valueStart, attr.valueEnd];\n}\nfunction shiftAttributeRanges(attrs, offset) {\n    attrs.forEach(attr => {\n        attr.nameStart += offset;\n        attr.nameEnd += offset;\n        if ('value' in attr) {\n            attr.valueStart += offset;\n            attr.valueEnd += offset;\n        }\n    });\n    return attrs;\n}\n\n/**\n * Returns context CSS section for given location in source code\n * @param properties Parse inner properties\n */\nfunction getCSSSection(code, pos, properties) {\n    const stack = [];\n    const pool = [];\n    let result;\n    scan$1(code, (type, start, end, delimiter) => {\n        if (start > pos && !stack.length) {\n            return false;\n        }\n        if (type === \"selector\" /* Selector */) {\n            stack.push(allocRange(pool, start, end, delimiter));\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            const sel = stack.pop();\n            if (sel && sel[0] <= pos && pos <= end) {\n                result = {\n                    start: sel[0],\n                    end,\n                    bodyStart: sel[2] + 1,\n                    bodyEnd: start\n                };\n                return false;\n            }\n            releaseRange(pool, sel);\n        }\n    });\n    if (result && properties) {\n        result.properties = parseProperties(code, result.bodyStart, result.bodyEnd);\n    }\n    return result;\n}\n/**\n * Returns list of ranges for Select Next/Previous CSS Item  action\n */\nfunction selectItemCSS(code, pos, isPrev) {\n    return isPrev ? selectPreviousItem$1(code, pos) : selectNextItem$1(code, pos);\n}\n/**\n * Returns regions for selecting next item in CSS\n */\nfunction selectNextItem$1(code, pos) {\n    let result = void 0;\n    let pendingProperty = void 0;\n    scan$1(code, (type, start, end, delimiter) => {\n        if (start < pos) {\n            return;\n        }\n        if (type === \"selector\" /* Selector */) {\n            result = { start, end, ranges: [[start, end]] };\n            return false;\n        }\n        else if (type === \"propertyName\" /* PropertyName */) {\n            pendingProperty = [start, end, delimiter];\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            result = {\n                start,\n                end: delimiter !== -1 ? delimiter + 1 : end,\n                ranges: []\n            };\n            if (pendingProperty) {\n                // Full property range\n                result.start = pendingProperty[0];\n                pushRange(result.ranges, [pendingProperty[0], result.end]);\n            }\n            // Full value range\n            pushRange(result.ranges, [start, end]);\n            // Value fragments\n            for (const r of splitValue(code.substring(start, end))) {\n                pushRange(result.ranges, [r[0] + start, r[1] + start]);\n            }\n            return false;\n        }\n        else if (pendingProperty) {\n            result = {\n                start: pendingProperty[0],\n                end: pendingProperty[1],\n                ranges: [[pendingProperty[0], pendingProperty[1]]]\n            };\n            return false;\n        }\n    });\n    return result;\n}\n/**\n * Returns regions for selecting previous item in CSS\n */\nfunction selectPreviousItem$1(code, pos) {\n    const state = {\n        type: null,\n        start: -1,\n        end: -1,\n        valueStart: -1,\n        valueEnd: -1,\n        valueDelimiter: -1,\n    };\n    scan$1(code, (type, start, end, delimiter) => {\n        // Accumulate context until we reach given position\n        if (start >= pos && type !== \"propertyValue\" /* PropertyValue */) {\n            return false;\n        }\n        if (type === \"selector\" /* Selector */ || type === \"propertyName\" /* PropertyName */) {\n            state.start = start;\n            state.end = end;\n            state.type = type;\n            state.valueStart = state.valueEnd = state.valueDelimiter = -1;\n        }\n        else if (type === \"propertyValue\" /* PropertyValue */) {\n            state.valueStart = start;\n            state.valueEnd = end;\n            state.valueDelimiter = delimiter;\n        }\n    });\n    if (state.type === \"selector\" /* Selector */) {\n        return {\n            start: state.start,\n            end: state.end,\n            ranges: [[state.start, state.end]]\n        };\n    }\n    if (state.type === \"propertyName\" /* PropertyName */) {\n        const result = {\n            start: state.start,\n            end: state.end,\n            ranges: []\n        };\n        if (state.valueStart !== -1) {\n            result.end = state.valueDelimiter !== -1 ? state.valueDelimiter + 1 : state.valueEnd;\n            // Full property range\n            pushRange(result.ranges, [state.start, result.end]);\n            // Full value range\n            pushRange(result.ranges, [state.valueStart, state.valueEnd]);\n            // Value fragments\n            for (const r of splitValue(code.substring(state.valueStart, state.valueEnd))) {\n                pushRange(result.ranges, [r[0] + state.valueStart, r[1] + state.valueStart]);\n            }\n        }\n        else {\n            pushRange(result.ranges, [state.start, state.end]);\n        }\n        return result;\n    }\n}\n/**\n * Parses properties in `from:to` fragment of `code`. Note that `from:to` must\n * point to CSS section content, e.g. *inside* `{` and `}` (or top-level code context),\n * all properties found in nested sections will be ignored\n */\nfunction parseProperties(code, from = 0, to = code.length) {\n    const fragment = code.substring(from, to);\n    const result = [];\n    const pool = [];\n    let pendingName;\n    let nested = 0;\n    let before = from;\n    scan$1(fragment, (type, start, end, delimiter) => {\n        if (type === \"selector\" /* Selector */) {\n            nested++;\n        }\n        else if (type === \"blockEnd\" /* BlockEnd */) {\n            nested--;\n            before = from + end;\n        }\n        else if (!nested) {\n            if (type === \"propertyName\" /* PropertyName */) {\n                if (pendingName) {\n                    // Create property with empty value\n                    const valuePos = pendingName[2];\n                    result.push(createProperty(fragment, pendingName, before, valuePos, valuePos, valuePos, from));\n                    releaseRange(pool, pendingName);\n                    before = from + start;\n                }\n                pendingName = allocRange(pool, start, end, delimiter);\n            }\n            else if (type === \"propertyValue\" /* PropertyValue */) {\n                if (pendingName) {\n                    result.push(createProperty(fragment, pendingName, before, start, end, delimiter, from));\n                    releaseRange(pool, pendingName);\n                    pendingName = void 0;\n                }\n                before = from + delimiter + 1;\n            }\n        }\n    });\n    return result;\n}\nfunction createProperty(code, name, before, start, end, delimiter, offset = 0) {\n    return {\n        name: [offset + name[0], offset + name[1]],\n        value: [offset + start, offset + end],\n        valueTokens: splitValue(code.substring(start, end), offset + start),\n        before,\n        after: offset + delimiter + 1,\n    };\n}\n/**\n * Allocates new token range from pool\n */\nfunction allocRange(pool, start, end, delimiter) {\n    if (pool.length) {\n        const range = pool.pop();\n        range[0] = start;\n        range[1] = end;\n        range[2] = delimiter;\n        return range;\n    }\n    return [start, end, delimiter];\n}\n/**\n * Releases given token range and pushes it back into the pool\n */\nfunction releaseRange(pool, range) {\n    range && pool.push(range);\n    return null;\n}\n\n/**\n * Returns HTML context for given location in source code\n */\nfunction getHTMLContext(code, pos, opt = {}) {\n    const result = {\n        type: 'html',\n        ancestors: [],\n        current: null,\n        css: null\n    };\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool = [];\n    const stack = [];\n    const options = createOptions({ xml: opt.xml, allTokens: true });\n    scan(code, (name, type, start, end) => {\n        if (start >= pos) {\n            // Moved beyond location, stop parsing\n            return false;\n        }\n        if (start < pos && pos < end) {\n            // Direct hit on element\n            result.current = { name, type, range: [start, end] };\n            return false;\n        }\n        if (type === 1 /* Open */ && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = 3 /* SelfClose */;\n        }\n        if (type === 1 /* Open */) {\n            // Allocate tag object from pool\n            stack.push(allocItem(pool, name, type, start, end));\n        }\n        else if (type === 2 /* Close */ && stack.length && last(stack).name === name) {\n            // Release tag object for further re-use\n            releaseItem(pool, stack.pop());\n        }\n    }, options);\n    // Record stack elements as ancestors\n    stack.forEach(item => {\n        result.ancestors.push({\n            name: item.name,\n            range: [item.start, item.end]\n        });\n    });\n    if (!opt.skipCSS) {\n        // Detect if position is inside CSS context\n        result.css = detectCSSContextFromHTML(code, pos, result);\n    }\n    return result;\n}\n/**\n * Returns CSS context for given location in source code\n */\nfunction getCSSContext(code, pos, embedded) {\n    const result = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: false,\n        embedded\n    };\n    const pool = [];\n    const stack = [];\n    scan$1(code, (type, start, end) => {\n        if (start >= pos) {\n            // Token behind specified location, stop parsing\n            return false;\n        }\n        if (start < pos && pos <= end) {\n            // Direct hit on token\n            result.current = {\n                name: code.slice(start, end),\n                type,\n                range: [start, end]\n            };\n            return false;\n        }\n        switch (type) {\n            case \"selector\" /* Selector */:\n            case \"propertyName\" /* PropertyName */:\n                stack.push(allocItem(pool, code.slice(start, end), type, start, end));\n                break;\n            case \"propertyValue\" /* PropertyValue */:\n            case \"blockEnd\" /* BlockEnd */:\n                stack.pop();\n                break;\n        }\n    });\n    stack.forEach(item => {\n        result.ancestors.push({\n            name: item.name,\n            type: item.type,\n            range: [item.start, item.end]\n        });\n    });\n    return result;\n}\n/**\n * Returns embedded stylesheet syntax from given HTML context\n */\nfunction getEmbeddedStyleSyntax(code, ctx) {\n    const parent = last(ctx.ancestors);\n    if (parent && parent.name === 'style') {\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            if (attr.name === 'type') {\n                return attributeValue(attr);\n            }\n        }\n    }\n}\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nfunction getMarkupAbbreviationContext(code, ctx) {\n    const parent = last(ctx.ancestors);\n    if (parent) {\n        const attrs = {};\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            attrs[attr.name] = attributeValue(attr) || '';\n        }\n        return {\n            name: parent.name,\n            attributes: attrs\n        };\n    }\n}\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nfunction getStylesheetAbbreviationContext(ctx) {\n    if (ctx.inline) {\n        return { name: \"@@property\" /* Property */ };\n    }\n    const parent = last(ctx.ancestors);\n    let scope = \"@@global\" /* Global */;\n    if (ctx.current) {\n        if (ctx.current.type === \"propertyValue\" /* PropertyValue */ && parent) {\n            scope = parent.name;\n        }\n        else if ((ctx.current.type === \"selector\" /* Selector */ || ctx.current.type === \"propertyName\" /* PropertyName */) && !parent) {\n            scope = \"@@section\" /* Section */;\n        }\n    }\n    return {\n        name: scope\n    };\n}\n/**\n * Tries to detect CSS context from given HTML context and returns it\n */\nfunction detectCSSContextFromHTML(code, pos, ctx) {\n    let cssCtx = null;\n    if (ctx.current) {\n        // Maybe inline CSS?\n        const elem = ctx.current;\n        if (elem.type === 1 /* Open */ || elem.type === 2 /* Close */) {\n            const tag = code.slice(elem.range[0], elem.range[1]);\n            attributes(tag, elem.name).some(attr => {\n                if (attr.name === 'style' && attr.value != null) {\n                    const [valueStart, valueEnd] = attributeValueRange(tag, attr, elem.range[0]);\n                    if (pos >= valueStart && pos <= valueEnd) {\n                        cssCtx = getCSSContext(code.slice(valueStart, valueEnd), pos - valueStart, [valueStart, valueEnd]);\n                        applyOffset(cssCtx, valueStart);\n                        cssCtx.inline = true;\n                        return true;\n                    }\n                }\n            });\n        }\n    }\n    else if (ctx.ancestors.length) {\n        // Maybe inside `<style>` element?\n        const parent = last(ctx.ancestors);\n        if (parent.name === 'style') {\n            // Find closing </style> tag\n            const styleStart = parent.range[1];\n            let styleEnd = code.length;\n            scan(code.slice(parent.range[1]), (name, type, start) => {\n                if (name === parent.name && type === 2 /* Close */) {\n                    styleEnd = start + styleStart;\n                    return false;\n                }\n            });\n            cssCtx = getCSSContext(code.slice(styleStart, styleEnd), pos - styleStart, [styleStart, styleEnd]);\n            applyOffset(cssCtx, styleStart);\n        }\n    }\n    return cssCtx;\n}\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name, options) {\n    return !options.xml && options.empty.includes(name);\n}\nfunction allocItem(pool, name, type, start, end) {\n    if (pool.length) {\n        const tag = pool.pop();\n        tag.name = name;\n        tag.type = type;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, type, start, end };\n}\nfunction releaseItem(pool, item) {\n    pool.push(item);\n}\nfunction applyOffset(ctx, offset) {\n    ctx.ancestors.forEach(item => {\n        offsetRange(item.range, offset);\n    });\n    if (ctx.current) {\n        offsetRange(ctx.current.range, offset);\n    }\n}\nfunction offsetRange(range, offset) {\n    range[0] += offset;\n    range[1] += offset;\n}\n\nconst JSX_PREFIX = '<';\nconst reJSXAbbrStart = /^[a-zA-Z.#\\[\\(]$/;\nconst reWordBound = /^[\\s>;\"\\']?[a-zA-Z.#!@\\[\\(]$/;\nconst reStylesheetWordBound = /^[\\s;\"\\']?[a-zA-Z!@]$/;\n/**\n * Controller for tracking Emmet abbreviations in editor as user types.\n * Controller designed to be extended ad-hoc in editor plugins, overriding some\n * methods `mark()` to match editor behavior\n */\nclass AbbreviationTrackingController {\n    constructor() {\n        this.cache = new Map();\n        this.trackers = new Map();\n        this.lastPos = new Map();\n    }\n    /**\n     * Returns last known location of caret in given editor\n     */\n    getLastPost(editor) {\n        return this.lastPos.get(editor.id);\n    }\n    /**\n     * Sets last known caret location for given editor\n     */\n    setLastPos(editor, pos) {\n        this.lastPos.set(editor.id, pos);\n    }\n    /**\n     * Returns abbreviation tracker for given editor, if any\n     */\n    getTracker(editor) {\n        return this.trackers.get(editor.id);\n    }\n    /**\n     * Detects if user is typing abbreviation at given location\n     */\n    typingAbbreviation(editor, pos) {\n        var _a;\n        // Start tracking only if user starts abbreviation typing: entered first\n        // character at the word bound\n        // NB: get last 2 characters: first should be a word bound(or empty),\n        // second must be abbreviation start\n        const prefix = editor.substr(Math.max(0, pos - 2), pos);\n        const syntax = editor.syntax();\n        let start = -1;\n        let end = pos;\n        let offset = 0;\n        if (editor.isJSX(syntax)) {\n            // In JSX, abbreviations should be prefixed\n            if (prefix.length === 2 && prefix[0] === JSX_PREFIX && reJSXAbbrStart.test(prefix[1])) {\n                start = pos - 2;\n                offset = JSX_PREFIX.length;\n            }\n        }\n        else if (reWordBound.test(prefix)) {\n            start = pos - 1;\n        }\n        if (start >= 0) {\n            // Check if there’s paired character\n            const lastCh = prefix[prefix.length - 1];\n            if (lastCh in pairs && editor.substr(pos, pos + 1) === pairs[lastCh]) {\n                end++;\n            }\n            const config = this.getActivationContext(editor, pos);\n            if (config) {\n                if (config.type === 'stylesheet' && !reStylesheetWordBound.test(prefix)) {\n                    // Additional check for stylesheet abbreviation start: it’s slightly\n                    // differs from markup prefix, but we need activation context\n                    // to ensure that context under caret is CSS\n                    return;\n                }\n                const tracker = this.startTracking(editor, start, end, { offset, config });\n                if (tracker && tracker.type === \"abbreviation\" /* Abbreviation */ && ((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n                    // Make a silly check for section context: if user start typing\n                    // CSS selector at the end of file, it will be treated as property\n                    // name and provide unrelated completion by default.\n                    // We should check if captured abbreviation actually matched\n                    // snippet to continue. Otherwise, ignore this abbreviation.\n                    // By default, unresolved abbreviations are converted to CSS properties,\n                    // e.g. `a` → `a: ;`. If that’s the case, stop tracking\n                    const { abbreviation, preview } = tracker;\n                    if (preview.startsWith(abbreviation) && /^:\\s*;?$/.test(preview.slice(abbreviation.length))) {\n                        this.stopTracking(editor);\n                        return;\n                    }\n                }\n                return tracker;\n            }\n        }\n    }\n    /**\n     * Starts abbreviation tracking for given editor\n     * @param start Location of abbreviation start\n     * @param pos Current caret position, must be greater that `start`\n     */\n    startTracking(editor, start, pos, params) {\n        const config = (params === null || params === void 0 ? void 0 : params.config) || editor.config(start);\n        const tracker = this.createTracker(editor, [start, pos], Object.assign({ config }, params));\n        if (tracker) {\n            this.trackers.set(editor.id, tracker);\n            return tracker;\n        }\n        this.trackers.delete(editor.id);\n    }\n    /**\n     * Stops abbreviation tracking in given editor instance\n     */\n    stopTracking(editor, params) {\n        const tracker = this.getTracker(editor);\n        if (tracker) {\n            editor.unmark(tracker);\n            if (tracker.forced && !(params === null || params === void 0 ? void 0 : params.skipRemove)) {\n                // Contents of forced abbreviation must be removed\n                editor.replace('', tracker.range[0], tracker.range[1]);\n            }\n            if (params === null || params === void 0 ? void 0 : params.force) {\n                this.cache.delete(editor.id);\n            }\n            else {\n                // Store tracker in history to restore it if user continues editing\n                this.storeTracker(editor, tracker);\n            }\n            this.trackers.delete(editor.id);\n        }\n    }\n    /**\n     * Creates abbreviation tracker for given range in editor. Parses contents\n     * of abbreviation in range and returns either valid abbreviation tracker,\n     * error tracker or `null` if abbreviation cannot be created from given range\n     */\n    createTracker(editor, range, params) {\n        if (range[0] >= range[1]) {\n            // Invalid range\n            return null;\n        }\n        let abbreviation = editor.substr(range[0], range[1]);\n        const { config } = params;\n        if (params.offset) {\n            abbreviation = abbreviation.slice(params.offset);\n        }\n        // Basic validation: do not allow empty abbreviations\n        // or newlines in abbreviations\n        if (!abbreviation || /[\\r\\n]/.test(abbreviation)) {\n            return null;\n        }\n        const base = {\n            abbreviation,\n            range,\n            config,\n            forced: !!params.forced,\n            offset: params.offset || 0,\n            lastPos: range[1],\n            lastLength: editor.size(),\n        };\n        try {\n            let parsedAbbr;\n            let simple = false;\n            if (config.type === 'stylesheet') {\n                parsedAbbr = stylesheetAbbreviation(abbreviation);\n            }\n            else {\n                parsedAbbr = markupAbbreviation(abbreviation, {\n                    jsx: config.syntax === 'jsx'\n                });\n                simple = this.isSimpleMarkupAbbreviation(parsedAbbr);\n            }\n            const previewConfig = editor.previewConfig(config);\n            return Object.assign(Object.assign({}, base), { type: \"abbreviation\" /* Abbreviation */, simple, preview: expand(parsedAbbr, previewConfig) });\n        }\n        catch (error) {\n            return Object.assign(Object.assign({}, base), { type: \"error\" /* Error */, error });\n        }\n    }\n    /**\n     * Stores given tracker in separate cache to restore later\n     */\n    storeTracker(editor, tracker) {\n        this.cache.set(editor.id, tracker);\n    }\n    /**\n     * Returns stored tracker for given editor proxy, if any\n     */\n    getStoredTracker(editor) {\n        return this.cache.get(editor.id);\n    }\n    /**\n     * Tries to restore abbreviation tracker for given editor at specified position\n     */\n    restoreTracker(editor, pos) {\n        const tracker = this.getStoredTracker(editor);\n        if (tracker && tracker.range[0] <= pos && tracker.range[1] >= pos) {\n            // Tracker can be restored at given location. Make sure it’s contents matches\n            // contents of editor at the same location. If it doesn’t, reset stored tracker\n            // since it’s not valid anymore\n            this.cache.delete(editor.id);\n            const [from, to] = tracker.range;\n            if (editor.substr(from + tracker.offset, to) === tracker.abbreviation) {\n                this.trackers.set(editor.id, tracker);\n                return tracker;\n            }\n        }\n    }\n    /**\n     * Handle content change in given editor instance\n     */\n    handleChange(editor, pos) {\n        const tracker = this.getTracker(editor);\n        const editorLastPos = this.getLastPost(editor);\n        this.setLastPos(editor, pos);\n        if (!tracker) {\n            // No active tracker, check if we user is actually typing it\n            if (editorLastPos != null && editorLastPos === pos - 1 && editor.allowTracking(pos)) {\n                return this.typingAbbreviation(editor, pos);\n            }\n            return;\n        }\n        const { lastPos } = tracker;\n        let { range } = tracker;\n        if (lastPos < range[0] || lastPos > range[1]) {\n            // Updated content outside abbreviation: reset tracker\n            this.stopTracking(editor);\n            return;\n        }\n        const length = editor.size();\n        const delta = length - tracker.lastLength;\n        range = range.slice();\n        // Modify range and validate it: if it leads to invalid abbreviation, reset tracker\n        updateRange(range, delta, lastPos);\n        // Handle edge case: empty forced abbreviation is allowed\n        if (range[0] === range[1] && tracker.forced) {\n            tracker.abbreviation = '';\n            return tracker;\n        }\n        const nextTracker = this.createTracker(editor, range, tracker);\n        if (!nextTracker || (!tracker.forced && !isValidTracker(nextTracker, range, pos))) {\n            this.stopTracking(editor);\n            return;\n        }\n        nextTracker.lastPos = pos;\n        this.trackers.set(editor.id, nextTracker);\n        editor.mark(nextTracker);\n        return nextTracker;\n    }\n    /**\n     * Handle selection (caret) change in given editor instance\n     */\n    handleSelectionChange(editor, pos) {\n        this.setLastPos(editor, pos);\n        const tracker = this.getTracker(editor) || this.restoreTracker(editor, pos);\n        if (tracker) {\n            tracker.lastPos = pos;\n            return tracker;\n        }\n    }\n    /**\n     * Detects and returns valid abbreviation activation context for given location\n     * in editor which can be used for abbreviation expanding.\n     * For example, in given HTML code:\n     * `<div title=\"Sample\" style=\"\">Hello world</div>`\n     * it’s not allowed to expand abbreviations inside `<div ...>` or `</div>`,\n     * yet it’s allowed inside `style` attribute and between tags.\n     *\n     * This method ensures that given `pos` is inside location allowed for expanding\n     * abbreviations and returns context data about it.\n     *\n     * Default implementation works for any editor since it uses own parsers for HTML\n     * and CSS but might be slow: if your editor supports low-level access to document\n     * parse tree or tokens, authors should override this method and provide alternative\n     * based on editor native features.\n     */\n    getActivationContext(editor, pos) {\n        const syntax = editor.syntax();\n        const content = editor.substr();\n        if (editor.isCSS(syntax)) {\n            return this.getCSSActivationContext(editor, pos, syntax, getCSSContext(content, pos));\n        }\n        if (editor.isHTML(syntax)) {\n            const ctx = getHTMLContext(content, pos, { xml: editor.isXML(syntax) });\n            if (ctx.css) {\n                return this.getCSSActivationContext(editor, pos, getEmbeddedStyleSyntax(content, ctx) || 'css', ctx.css);\n            }\n            if (!ctx.current) {\n                return {\n                    syntax,\n                    type: 'markup',\n                    context: getMarkupAbbreviationContext(content, ctx),\n                    options: editor.outputOptions(pos)\n                };\n            }\n        }\n        else {\n            return {\n                syntax,\n                type: editor.syntaxType(syntax)\n            };\n        }\n    }\n    getCSSActivationContext(editor, pos, syntax, ctx) {\n        // CSS abbreviations can be activated only when a character is entered, e.g.\n        // it should be either property name or value.\n        // In come cases, a first character of selector should also be considered\n        // as activation context\n        if (!ctx.current) {\n            return void 0;\n        }\n        const allowedContext = ctx.current.type === \"propertyName\" /* PropertyName */\n            || ctx.current.type === \"propertyValue\" /* PropertyValue */\n            || this.isTypingBeforeSelector(editor, pos, ctx);\n        if (allowedContext) {\n            return {\n                syntax,\n                type: 'stylesheet',\n                context: getStylesheetAbbreviationContext(ctx),\n                options: editor.outputOptions(pos, ctx.inline)\n            };\n        }\n    }\n    /**\n     * Handle edge case: start typing abbreviation before selector. In this case,\n     * entered character becomes part of selector\n     * Activate only if it’s a nested section and it’s a first character of selector\n     */\n    isTypingBeforeSelector(editor, pos, { current }) {\n        if (current && current.type === \"selector\" /* Selector */ && current.range[0] === pos - 1) {\n            // Typing abbreviation before selector is tricky one:\n            // ensure it’s on its own line\n            const line = editor.substr(current.range[0], current.range[1]).split(/[\\n\\r]/)[0];\n            return line.trim().length === 1;\n        }\n        return false;\n    }\n    /**\n     * Check if given parsed markup abbreviation is simple.A simple abbreviation\n     * may not be displayed to user as preview to reduce distraction\n     */\n    isSimpleMarkupAbbreviation(abbr) {\n        if (abbr.children.length === 1 && !abbr.children[0].children.length) {\n            // Single element: might be a HTML element or text snippet\n            const first = abbr.children[0];\n            // XXX silly check for common snippets like `!`. Should read contents\n            // of expanded abbreviation instead\n            return !first.name || /^[a-z]/i.test(first.name);\n        }\n        return !abbr.children.length;\n    }\n    /**\n     * Method should be called when given editor instance will be no longer\n     * available to clean up cached data\n     */\n    disposeEditor(editor) {\n        this.cache.delete(editor.id);\n        this.trackers.delete(editor.id);\n        this.lastPos.delete(editor.id);\n    }\n}\nfunction updateRange(range, delta, lastPos) {\n    if (delta < 0) {\n        // Content removed\n        if (lastPos === range[0]) {\n            // Updated content at the abbreviation edge\n            range[0] += delta;\n            range[1] += delta;\n        }\n        else if (range[0] < lastPos && lastPos <= range[1]) {\n            range[1] += delta;\n        }\n    }\n    else if (delta > 0 && range[0] <= lastPos && lastPos <= range[1]) {\n        // Content inserted\n        range[1] += delta;\n    }\n    return range;\n}\n/**\n * Check if given tracker is in valid state for keeping it marked\n */\nfunction isValidTracker(tracker, range, pos) {\n    if (tracker.type === \"error\" /* Error */) {\n        if (range[1] === pos) {\n            // Last entered character is invalid\n            return false;\n        }\n        const { abbreviation } = tracker;\n        const start = range[0];\n        let targetPos = range[1];\n        while (targetPos > start) {\n            if (pairsEnd.includes(abbreviation[targetPos - start - 1])) {\n                targetPos--;\n            }\n            else {\n                break;\n            }\n        }\n        return targetPos !== pos;\n    }\n    return true;\n}\n\nexport { AbbreviationTrackingController, JSX_PREFIX, findTagMatch, getCSSContext, getCSSSection, getHTMLContext, getOpenTag, getTagMatches, selectItemCSS, selectItemHTML };\n//# sourceMappingURL=action-utils.es.js.map\n","import { AttributeToken } from '@emmetio/html-matcher';\nimport { CSSProperty, TextRange } from '@emmetio/action-utils';\n\n/** Characters to indicate tab stop start and end in generated snippet */\nexport const tabStopStart = String.fromCodePoint(0xFFF0);\nexport const tabStopEnd = String.fromCodePoint(0xFFF1);\nexport const stateKey = '$$emmet';\n\nexport interface AbbrError {\n    message: string,\n    pos: number\n}\n\nexport interface CMRange {\n    anchor: CodeMirror.Position;\n    head: CodeMirror.Position;\n}\n\nexport type DisposeFn = () => void;\n\nexport interface EmmetState {\n    id: string;\n    tracker?: DisposeFn | null;\n    tagMatch?: DisposeFn | null;\n}\n\nexport const pairs = {\n    '{': '}',\n    '[': ']',\n    '(': ')'\n};\n\nexport const pairsEnd: string[] = [];\nfor (const key of Object.keys(pairs)) {\n    pairsEnd.push(pairs[key]);\n}\n\nlet idCounter = 0;\n\n/**\n * Returns copy of region which starts and ends at non-space character\n */\nexport function narrowToNonSpace(editor: CodeMirror.Editor, range: TextRange): TextRange {\n    const text = substr(editor, range);\n    let startOffset = 0;\n    let endOffset = text.length;\n\n    while (startOffset < endOffset && isSpace(text[startOffset])) {\n        startOffset++;\n    }\n\n    while (endOffset > startOffset && isSpace(text[endOffset - 1])) {\n        endOffset--;\n    }\n\n    return [range[0] + startOffset, range[0] + endOffset];\n}\n\n/**\n * Replaces given range in editor with snippet contents\n */\nexport function replaceWithSnippet(editor: CodeMirror.Editor, range: TextRange, snippet: string): boolean {\n    let fieldStartIx = snippet.indexOf(tabStopStart);\n    let fieldEndIx = snippet.indexOf(tabStopEnd);\n    let selFrom: number | undefined;\n    let selTo: number | undefined;\n\n    if (fieldStartIx !== -1 && fieldEndIx !== -1) {\n        selFrom = range[0] + fieldStartIx;\n        selTo = range[0] + fieldEndIx - tabStopStart.length;\n        snippet = snippet.slice(0, fieldStartIx)\n            + snippet.slice(fieldStartIx + tabStopStart.length, fieldEndIx)\n            + snippet.slice(fieldEndIx + tabStopEnd.length);\n    } else if (fieldStartIx !== -1) {\n        selFrom = range[0] + fieldStartIx;\n        snippet = snippet.slice(0, fieldStartIx)\n            + snippet.slice(fieldStartIx + tabStopStart.length);\n    }\n\n    return editor.operation(() => {\n        const [from, to] = toRange(editor, range);\n        editor.replaceRange(snippet, from, to);\n\n        // Position cursor\n        if (selFrom != null) {\n            const selFromPos = editor.posFromIndex(selFrom);\n            const selToPos = selTo != null ? editor.posFromIndex(selTo) : void 0;\n            if (selToPos) {\n                editor.setSelection(selFromPos, selToPos);\n            } else {\n                editor.setCursor(selFromPos);\n            }\n        }\n\n        return true;\n    });\n}\n\n/**\n * Returns current caret position for single selection\n */\nexport function getCaret(editor: CodeMirror.Editor): number {\n    const pos = editor.getCursor();\n    return editor.indexFromPos(pos);\n}\n\n/**\n * Returns full text content of given editor\n */\nexport function getContent(editor: CodeMirror.Editor): string {\n    return editor.getValue();\n}\n\n/**\n * Returns substring of given editor content for specified range\n */\nexport function substr(editor: CodeMirror.Editor, range: TextRange): string {\n    const [from, to] = toRange(editor, range);\n    return editor.getRange(from, to);\n}\n\n/**\n * Converts given index range to editor’s position range\n */\nexport function toRange(editor: CodeMirror.Editor, range: TextRange): [CodeMirror.Position, CodeMirror.Position] {\n    return [\n        editor.posFromIndex(range[0]),\n        editor.posFromIndex(range[1])\n    ];\n}\n\n/**\n * Returns value of given attribute, parsed by Emmet HTML matcher\n */\nexport function attributeValue(attr: AttributeToken): string | undefined {\n    const { value } = attr\n    return value && isQuoted(value)\n        ? value.slice(1, -1)\n        : value;\n}\n\n/**\n * Returns region that covers entire attribute\n */\nexport function attributeRange(attr: AttributeToken): TextRange {\n    const end = attr.value != null ? attr.valueEnd! : attr.nameEnd;\n    return [attr.nameStart, end];\n}\n\n/**\n * Returns patched version of given HTML attribute, parsed by Emmet HTML matcher\n */\nexport function patchAttribute(attr: AttributeToken, value: string | number, name = attr.name) {\n    let before = '';\n    let after = '';\n\n    if (attr.value != null) {\n        if (isQuoted(attr.value)) {\n            // Quoted value or React-like expression\n            before = attr.value[0];\n            after = attr.value[attr.value.length - 1];\n        }\n    } else {\n        // Attribute without value (boolean)\n        before = after = '\"';\n    }\n\n    return `${name}=${before}${value}${after}`;\n}\n\n/**\n * Returns patched version of given CSS property, parsed by Emmet CSS matcher\n */\nexport function patchProperty(editor: CodeMirror.Editor, prop: CSSProperty, value: string, name?: string) {\n    if (name == null) {\n        name = substr(editor, prop.name);\n    }\n\n    const before = substr(editor, [prop.before, prop.name[0]]);\n    const between = substr(editor, [prop.name[1], prop.value[0]]);\n    const after = substr(editor, [prop.value[1], prop.after]);\n\n    return [before, name, between, value, after].join('');\n}\n\n/**\n * Check if given value is either quoted or written as expression\n */\nexport function isQuoted(value: string | undefined): boolean {\n    return !!value && (isQuotedString(value) || isExprString(value));\n}\n\nexport function isQuote(ch: string | undefined) {\n    return ch === '\"' || ch === \"'\";\n}\n\n/**\n * Check if given string is quoted with single or double quotes\n */\nexport function isQuotedString(str: string): boolean {\n    return str.length > 1 && isQuote(str[0]) && str[0] === str.slice(-1);\n}\n\n/**\n * Check if given string contains expression, e.g. wrapped with `{` and `}`\n */\nfunction isExprString(str: string): boolean {\n    return str[0] === '{' && str.slice(-1) === '}';\n}\n\nexport function isSpace(ch: string): boolean {\n    return /^[\\s\\n\\r]+$/.test(ch);\n}\n\nexport function htmlEscape(str: string): string {\n    const replaceMap = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '&': '&amp;',\n    };\n    return str.replace(/[<>&]/g, ch => replaceMap[ch]);\n}\n\n/**\n * Returns special object for bypassing command handling\n */\nexport function pass(editor: CodeMirror.Editor) {\n    return editor.constructor['Pass'];\n}\n\n/**\n * Converts given CodeMirror range to text range\n */\nexport function textRange(editor: CodeMirror.Editor, range: CMRange): TextRange {\n    const head = editor.indexFromPos(range.head);\n    const anchor = editor.indexFromPos(range.anchor);\n    return [\n        Math.min(head, anchor),\n        Math.max(head, anchor)\n    ];\n}\n\n/**\n * Check if `a` and `b` contains the same range\n */\nexport function rangesEqual(a: TextRange, b: TextRange): boolean {\n    return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Check if range `a` fully contains range `b`\n */\nexport function rangeContains(a: TextRange, b: TextRange): boolean {\n    return a[0] <= b[0] && a[1] >= b[1];\n}\n\n/**\n * Check if given range is empty\n */\nexport function rangeEmpty(r: TextRange): boolean {\n    return r[0] === r[1];\n}\n\n/**\n * Generates snippet with error pointer\n */\nexport function errorSnippet(err: AbbrError, baseClass = 'emmet-error-snippet'): string {\n    const msg = err.message.split('\\n')[0];\n    const spacer = ' '.repeat(err.pos || 0);\n    return `<div class=\"${baseClass}\">\n        <div class=\"${baseClass}-ptr\">\n            <div class=\"${baseClass}-line\"></div>\n            <div class=\"${baseClass}-tip\"></div>\n            <div class=\"${baseClass}-spacer\">${spacer}</div>\n        </div>\n        <div class=\"${baseClass}-message\">${htmlEscape(msg.replace(/\\s+at\\s+\\d+$/, ''))}</div>\n    </div>`;\n}\n\n/**\n * Returns last element in given array\n */\nexport function last<T>(arr: T[]): T | undefined {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\n/**\n * Check if given editor instance has internal Emmet state\n */\nexport function hasInternalState(editor: CodeMirror.Editor): boolean {\n    return stateKey in editor;\n}\n\n/**\n * Returns internal Emmet state for given editor instance\n */\nexport function getInternalState(editor: CodeMirror.Editor): EmmetState {\n    if (!hasInternalState(editor)) {\n        editor[stateKey] = { id: String(idCounter++) } as EmmetState;\n    }\n\n    return editor[stateKey];\n}\n","import { SyntaxType, CSSAbbreviationScope, AbbreviationContext } from 'emmet';\nimport { TokenType } from '@emmetio/css-matcher';\nimport { attributes } from '@emmetio/html-matcher';\nimport { CSSContext, HTMLContext, getHTMLContext, getCSSContext } from '@emmetio/action-utils';\nimport { EnableForSyntax } from './config';\nimport { getContent, last, attributeValue } from './utils';\n\nconst xmlSyntaxes = ['xml', 'xsl', 'jsx'];\nconst htmlSyntaxes = ['html', 'htmlmixed', 'vue'];\nconst cssSyntaxes = ['css', 'scss', 'less'];\nconst jsxSyntaxes = ['jsx', 'tsx'];\nconst markupSyntaxes = ['haml', 'jade', 'pug', 'slim'].concat(htmlSyntaxes, xmlSyntaxes, jsxSyntaxes);\nconst stylesheetSyntaxes = ['sass', 'sss', 'stylus', 'postcss'].concat(cssSyntaxes);\n\nexport interface SyntaxInfo {\n    type: SyntaxType;\n    syntax?: string;\n    inline?: boolean;\n    context?: HTMLContext | CSSContext;\n}\n\nexport interface StylesheetRegion {\n    range: [number, number];\n    syntax: string;\n    inline?: boolean;\n}\n\nexport interface SyntaxCache {\n    stylesheetRegions?: StylesheetRegion[];\n}\n\n/**\n * Returns Emmet syntax info for given location in view.\n * Syntax info is an abbreviation type (either 'markup' or 'stylesheet') and syntax\n * name, which is used to apply syntax-specific options for output.\n *\n * By default, if given location doesn’t match any known context, this method\n * returns `null`, but if `fallback` argument is provided, it returns data for\n * given fallback syntax\n */\nexport function syntaxInfo(editor: CodeMirror.Editor, pos: number): SyntaxInfo {\n    let syntax = docSyntax(editor);\n    let inline: boolean | undefined;\n    let context: HTMLContext | CSSContext | undefined;\n\n    if (isHTML(syntax)) {\n        const content = getContent(editor);\n        context = getHTMLContext(content, pos, {\n            xml: isXML(syntax)\n        });\n\n        if (context.css) {\n            // `pos` is in embedded CSS\n            syntax = getEmbeddedStyleSyntax(content, context) || 'css';\n            inline = context.css.inline;\n            context = context.css;\n        }\n    } else if (isCSS(syntax)) {\n        context = getCSSContext(getContent(editor), pos);\n    }\n\n    return {\n        type: getSyntaxType(syntax),\n        syntax,\n        inline,\n        context\n    };\n}\n\n/**\n * Returns syntax for given position in editor\n */\nexport function syntaxFromPos(editor: CodeMirror.Editor, pos: number): string | undefined {\n    const p = editor.posFromIndex(pos);\n    const mode = editor.getModeAt(p);\n    if (mode && mode.name === 'xml') {\n        // XML mode is used for styling HTML as well\n        return mode.configuration || mode.name;\n    }\n    return mode && mode.name;\n}\n\n/**\n * Returns main editor syntax\n */\nexport function docSyntax(editor: CodeMirror.Editor): string {\n    const mode = editor.getMode();\n    if (mode) {\n        return mode.name === 'htmlmixed' ? 'html' : (mode.name || '');\n    }\n    return '';\n}\n\n/**\n * Returns Emmet abbreviation type for given syntax\n */\nexport function getSyntaxType(syntax?: string): SyntaxType {\n    return syntax && stylesheetSyntaxes.includes(syntax) ? 'stylesheet' : 'markup';\n}\n\n/**\n * Check if given syntax is XML dialect\n */\nexport function isXML(syntax?: string): boolean {\n    return syntax ? xmlSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given syntax is HTML dialect (including XML)\n */\nexport function isHTML(syntax?: string): boolean {\n    return syntax\n        ? htmlSyntaxes.includes(syntax) || isXML(syntax)\n        : false;\n}\n\n/**\n * Check if given syntax name is supported by Emmet\n */\nexport function isSupported(syntax: string): boolean {\n    return syntax\n        ? markupSyntaxes.includes(syntax) || stylesheetSyntaxes.includes(syntax)\n        : false;\n}\n\n/**\n * Check if given syntax is a CSS dialect. Note that it’s not the same as stylesheet\n * syntax: for example, SASS is a stylesheet but not CSS dialect (but SCSS is)\n */\nexport function isCSS(syntax?: string): boolean {\n    return syntax ? cssSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given syntax is JSX dialect\n */\nexport function isJSX(syntax?: string): boolean {\n    return syntax ? jsxSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given option if enabled for specified syntax\n */\nexport function enabledForSyntax(opt: EnableForSyntax, info: SyntaxInfo) {\n    if (opt === true) {\n        return true;\n    }\n\n    if (Array.isArray(opt)) {\n        const candidates: string[] = [info.type, info.syntax!];\n        if (info.inline) {\n            candidates.push(`${info.type}-inline`, `${info.syntax!}-inline`);\n        }\n\n        return candidates.some(c => opt.includes(c));\n    }\n\n    return false;\n}\n\n/**\n * Returns embedded stylesheet syntax from given HTML context\n */\nexport function getEmbeddedStyleSyntax(code: string, ctx: HTMLContext): string | undefined {\n    const parent = last(ctx.ancestors);\n    if (parent && parent.name === 'style') {\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            if (attr.name === 'type') {\n                return attributeValue(attr);\n            }\n        }\n    }\n}\n\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nexport function getMarkupAbbreviationContext(code: string, ctx: HTMLContext): AbbreviationContext | undefined {\n    const parent = last(ctx.ancestors);\n    if (parent) {\n        const attrs: { [name: string]: string } = {};\n        for (const attr of attributes(code.slice(parent.range[0], parent.range[1]), parent.name)) {\n            attrs[attr.name] = attributeValue(attr) || '';\n        }\n\n        return {\n            name: parent.name,\n            attributes: attrs\n        };\n    }\n}\n\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nexport function getStylesheetAbbreviationContext(ctx: CSSContext): AbbreviationContext {\n    if (ctx.inline) {\n        return { name: CSSAbbreviationScope.Property }\n    }\n\n    const parent = last(ctx.ancestors);\n    let scope: string = CSSAbbreviationScope.Global;\n    if (ctx.current) {\n        if (ctx.current.type === TokenType.PropertyValue && parent) {\n            scope = parent.name;\n        } else if ((ctx.current.type === TokenType.Selector || ctx.current.type === TokenType.PropertyName) && !parent) {\n            scope = CSSAbbreviationScope.Section;\n        }\n    }\n\n    return {\n        name: scope\n    };\n}\n","import Scanner, { isWhiteSpace, isNumber, isSpace } from '@emmetio/scanner';\n\nconst nullary = token(\"null\" /* Null */, 0);\n/**\n * Parses given expression in forward direction\n */\nfunction parse(expr) {\n    const scanner = typeof expr === 'string' ? new Scanner(expr) : expr;\n    let ch;\n    let priority = 0;\n    let expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n    const tokens = [];\n    while (!scanner.eof()) {\n        scanner.eatWhile(isWhiteSpace);\n        scanner.start = scanner.pos;\n        if (consumeNumber(scanner)) {\n            if ((expected & 1 /* Primary */) === 0) {\n                error('Unexpected number', scanner);\n            }\n            tokens.push(number(scanner.current()));\n            expected = (2 /* Operator */ | 8 /* RParen */);\n        }\n        else if (isOperator(scanner.peek())) {\n            ch = scanner.next();\n            if (isSign(ch) && (expected & 16 /* Sign */)) {\n                if (isNegativeSign(ch)) {\n                    tokens.push(op1(ch, priority));\n                }\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n            else {\n                if ((expected & 2 /* Operator */) === 0) {\n                    error('Unexpected operator', scanner);\n                }\n                tokens.push(op2(ch, priority));\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n        }\n        else if (scanner.eat(40 /* LeftParenthesis */)) {\n            if ((expected & 4 /* LParen */) === 0) {\n                error('Unexpected \"(\"', scanner);\n            }\n            priority += 10;\n            expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */ | 32 /* NullaryCall */);\n        }\n        else if (scanner.eat(41 /* RightParenthesis */)) {\n            priority -= 10;\n            if (expected & 32 /* NullaryCall */) {\n                tokens.push(nullary);\n            }\n            else if ((expected & 8 /* RParen */) === 0) {\n                error('Unexpected \")\"', scanner);\n            }\n            expected = (2 /* Operator */ | 8 /* RParen */ | 4 /* LParen */);\n        }\n        else {\n            error('Unknown character', scanner);\n        }\n    }\n    if (priority < 0 || priority >= 10) {\n        error('Unmatched \"()\"', scanner);\n    }\n    const result = orderTokens(tokens);\n    if (result === null) {\n        error('Parity', scanner);\n    }\n    return result;\n}\n/**\n * Consumes number from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */) && scanner.eatWhile(isNumber)) {\n        // short decimal notation: .025\n        return true;\n    }\n    if (scanner.eatWhile(isNumber) && (!scanner.eat(46 /* Dot */) || scanner.eatWhile(isNumber))) {\n        // either integer or decimal: 10, 10.25\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Orders parsed tokens (operands and operators) in given array so that they are\n * laid off in order of execution\n */\nfunction orderTokens(tokens) {\n    const operators = [];\n    const operands = [];\n    let nOperators = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        if (t.type === \"num\" /* Number */) {\n            operands.push(t);\n        }\n        else {\n            nOperators += t.type === \"op1\" /* Op1 */ ? 1 : 2;\n            while (operators.length) {\n                if (t.priority <= operators[operators.length - 1].priority) {\n                    operands.push(operators.pop());\n                }\n                else {\n                    break;\n                }\n            }\n            operators.push(t);\n        }\n    }\n    return nOperators + 1 === operands.length + operators.length\n        ? operands.concat(operators.reverse())\n        : null /* parity */;\n}\n/**\n * Number token factory\n */\nfunction number(value, priority) {\n    return token(\"num\" /* Number */, parseFloat(value), priority);\n}\n/**\n * Unary operator factory\n * @param value    Operator  character code\n * @param priority Operator execution priority\n */\nfunction op1(value, priority = 0) {\n    if (value === 45 /* Minus */) {\n        priority += 2;\n    }\n    return token(\"op1\" /* Op1 */, value, priority);\n}\n/**\n * Binary operator factory\n * @param value Operator  character code\n * @param priority Operator execution priority\n */\nfunction op2(value, priority = 0) {\n    if (value === 42 /* Multiply */) {\n        priority += 1;\n    }\n    else if (value === 47 /* Divide */ || value === 92 /* IntDivide */) {\n        priority += 2;\n    }\n    return token(\"op2\" /* Op2 */, value, priority);\n}\nfunction error(name, scanner) {\n    if (scanner) {\n        name += ` at column ${scanner.pos} of expression`;\n    }\n    throw new Error(name);\n}\nfunction isSign(ch) {\n    return isPositiveSign(ch) || isNegativeSign(ch);\n}\nfunction isPositiveSign(ch) {\n    return ch === 43 /* Plus */;\n}\nfunction isNegativeSign(ch) {\n    return ch === 45 /* Minus */;\n}\nfunction isOperator(ch) {\n    return ch === 43 /* Plus */ || ch === 45 /* Minus */ || ch === 42 /* Multiply */\n        || ch === 47 /* Divide */ || ch === 92 /* IntDivide */;\n}\nfunction token(type, value, priority = 0) {\n    return { type, value, priority };\n}\n\nconst defaultOptions = {\n    lookAhead: true,\n    whitespace: true\n};\nfunction extract(text, pos = text.length, options) {\n    const opt = Object.assign(Object.assign({}, defaultOptions), options);\n    const scanner = { text, pos };\n    let ch;\n    if (opt.lookAhead && cur(scanner) === 41 /* RightParenthesis */) {\n        // Basically, we should consume right parenthesis only with optional whitespace\n        scanner.pos++;\n        const len = text.length;\n        while (scanner.pos < len) {\n            ch = cur(scanner);\n            if (ch !== 41 /* RightParenthesis */ && !(opt.whitespace && isSpace(ch))) {\n                break;\n            }\n            scanner.pos++;\n        }\n    }\n    const end = scanner.pos;\n    let braces = 0;\n    while (scanner.pos >= 0) {\n        if (number$1(scanner)) {\n            continue;\n        }\n        ch = prev(scanner);\n        if (ch === 41 /* RightParenthesis */) {\n            braces++;\n        }\n        else if (ch === 40 /* LeftParenthesis */) {\n            if (!braces) {\n                break;\n            }\n            braces--;\n        }\n        else if (!((opt.whitespace && isSpace(ch)) || isSign(ch) || isOperator(ch))) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (scanner.pos !== end && !braces) {\n        // Trim whitespace\n        while (isSpace(cur(scanner))) {\n            scanner.pos++;\n        }\n        return [scanner.pos, end];\n    }\n    return null;\n}\n/**\n * Backward-consumes number from given scanner, if possible\n */\nfunction number$1(scanner) {\n    if (isNumber(prev(scanner))) {\n        scanner.pos--;\n        let dot = false;\n        let ch;\n        while (scanner.pos >= 0) {\n            ch = prev(scanner);\n            if (ch === 46 /* . */) {\n                if (dot) {\n                    // Decimal delimiter already consumed, abort\n                    break;\n                }\n                dot = true;\n            }\n            else if (!isNumber(ch)) {\n                break;\n            }\n            scanner.pos--;\n        }\n        return true;\n    }\n    return false;\n}\nfunction prev(scanner) {\n    return scanner.text.charCodeAt(scanner.pos - 1);\n}\nfunction cur(scanner) {\n    return scanner.text.charCodeAt(scanner.pos);\n}\n\nconst ops1 = {\n    [45 /* Minus */]: num => -num\n};\nconst ops2 = {\n    [43 /* Plus */]: (a, b) => a + b,\n    [45 /* Minus */]: (a, b) => a - b,\n    [42 /* Multiply */]: (a, b) => a * b,\n    [47 /* Divide */]: (a, b) => a / b,\n    [92 /* IntDivide */]: (a, b) => Math.floor(a / b)\n};\n/**\n * Evaluates given math expression\n * @param expr Expression to evaluate\n */\nfunction evaluate(expr) {\n    if (!Array.isArray(expr)) {\n        expr = parse(expr);\n    }\n    if (!expr || !expr.length) {\n        return null;\n    }\n    const nStack = [];\n    let n1;\n    let n2;\n    let f;\n    for (let i = 0, il = expr.length; i < il; i++) {\n        const token = expr[i];\n        if (token.type === \"num\" /* Number */) {\n            nStack.push(token.value);\n        }\n        else if (token.type === \"op2\" /* Op2 */) {\n            n2 = nStack.pop();\n            n1 = nStack.pop();\n            f = ops2[token.value];\n            nStack.push(f(n1, n2));\n        }\n        else if (token.type === \"op1\" /* Op1 */) {\n            n1 = nStack.pop();\n            f = ops1[token.value];\n            nStack.push(f(n1));\n        }\n        else {\n            throw new Error('Invalid expression');\n        }\n    }\n    if (nStack.length > 1) {\n        throw new Error('Invalid Expression (parity)');\n    }\n    return nStack[0];\n}\n\nexport default evaluate;\nexport { extract, parse };\n//# sourceMappingURL=math.es.js.map\n","import { Options } from 'emmet';\nimport getEmmetConfig from './config';\nimport { tabStopStart, tabStopEnd } from './utils';\nimport { isHTML, docSyntax } from './syntax';\n\nexport default function getOutputOptions(editor: CodeMirror.Editor, pos?: number, inline?: boolean): Partial<Options> {\n    const posObj: CodeMirror.Position = pos != null ? editor.posFromIndex(pos) : editor.getCursor();\n    const syntax = docSyntax(editor) || 'html';\n    const config = getEmmetConfig(editor);\n\n    const opt: Partial<Options> = {\n        'output.baseIndent': lineIndent(editor, posObj.line),\n        'output.indent': getIndentation(editor),\n        'output.field': field(),\n        'output.format': !inline,\n        'output.attributeQuotes': config.attributeQuotes\n    };\n\n    if (syntax === 'html') {\n        opt['output.selfClosingStyle'] = config.markupStyle;\n        opt['output.compactBoolean'] = config.markupStyle === 'html';\n    }\n\n    if (isHTML(syntax)) {\n        if (config.comments) {\n            opt['comment.enabled'] = true;\n            if (config.commentsTemplate) {\n                opt['comment.after'] = config.commentsTemplate;\n            }\n        }\n\n        opt['bem.enabled'] = config.bem;\n        opt['stylesheet.shortHex'] = config.shortHex;\n    }\n\n    return opt;\n}\n\n/**\n * Produces tabstop for CodeMirror editor\n */\nexport function field() {\n    let handled = false;\n    return (index: number, placeholder: string) => {\n        if (!handled) {\n            handled = true;\n            return placeholder\n                ? tabStopStart + placeholder + tabStopEnd\n                : tabStopStart;\n        }\n\n        return '';\n    }\n}\n\n/**\n * Returns indentation of given line\n */\nexport function lineIndent(editor: CodeMirror.Editor, line: number): string {\n    const lineStr = editor.getLine(line);\n    const indent = lineStr.match(/^\\s+/);\n    return indent ? indent[0] : '';\n}\n\n/**\n * Returns token used for single indentation in given editor\n */\nexport function getIndentation(editor: CodeMirror.Editor): string {\n    if (!editor.getOption('indentWithTabs')) {\n        return ' '.repeat(editor.getOption('indentUnit') || 0);\n    }\n\n    return '\\t';\n}\n","import expandAbbreviation, { extract as extractAbbreviation, UserConfig, AbbreviationContext, ExtractedAbbreviation, Options, ExtractOptions, resolveConfig, MarkupAbbreviation, StylesheetAbbreviation, SyntaxType } from 'emmet';\nimport match, { balancedInward, balancedOutward } from '@emmetio/html-matcher';\nimport { balancedInward as cssBalancedInward, balancedOutward as cssBalancedOutward } from '@emmetio/css-matcher';\nimport { selectItemCSS, selectItemHTML, TextRange } from '@emmetio/action-utils';\nimport evaluate, { extract as extractMath, ExtractOptions as MathExtractOptions } from '@emmetio/math-expression';\nimport { isXML, syntaxInfo, getMarkupAbbreviationContext, getStylesheetAbbreviationContext } from './syntax';\nimport { getContent, isQuotedString } from './utils';\nimport getEmmetConfig from './config';\nimport getOutputOptions, { field } from './output';\n\ninterface EvaluatedMath {\n    start: number;\n    end: number;\n    result: number;\n    snippet: string;\n}\n\nexport interface ContextTag extends AbbreviationContext {\n    open: TextRange;\n    close?: TextRange;\n}\n\nexport interface ExtractedAbbreviationWithContext extends ExtractedAbbreviation {\n    context?: AbbreviationContext;\n    inline?: boolean;\n}\n\n/**\n * Cache for storing internal Emmet data.\n * TODO reset whenever user settings are changed\n */\nlet cache = {};\n\nexport const JSX_PREFIX = '<';\n\n/**\n * Expands given abbreviation into code snippet\n */\nexport function expand(editor: CodeMirror.Editor, abbr: string | MarkupAbbreviation | StylesheetAbbreviation, config?: UserConfig) {\n    let opt: UserConfig = { cache };\n    const outputOpt: Partial<Options> = {\n        'output.field': field(),\n        'output.format': !config || !config['inline'],\n    };\n\n    if (config) {\n        Object.assign(opt, config);\n        if (config.options) {\n            Object.assign(outputOpt, config.options);\n        }\n    }\n\n    opt.options = outputOpt;\n\n    const pluginConfig = getEmmetConfig(editor);\n    if (pluginConfig.config) {\n        opt = resolveConfig(opt, pluginConfig.config);\n    }\n\n    return expandAbbreviation(abbr as string, opt);\n}\n\n/**\n * Extracts abbreviation from given source code by detecting actual syntax context.\n * For example, if host syntax is HTML, it tries to detect if location is inside\n * embedded CSS.\n *\n * It also detects if abbreviation is allowed at given location: HTML tags,\n * CSS selectors may not contain abbreviations.\n * @param code Code from which abbreviation should be extracted\n * @param pos Location at which abbreviation should be expanded\n * @param syntax Syntax of abbreviation to expand\n */\nexport function extract(code: string, pos: number, type: SyntaxType = 'markup', options?: Partial<ExtractOptions>): ExtractedAbbreviation | undefined {\n    return extractAbbreviation(code, pos, {\n        lookAhead: type !== 'stylesheet',\n        type,\n        ...options\n    });\n}\n\n/**\n * Returns list of tags for balancing for given code\n */\nexport function balance(code: string, pos: number, inward = false, xml = false) {\n    const options = { xml };\n    return inward\n        ? balancedInward(code, pos, options)\n        : balancedOutward(code, pos, options);\n}\n\n/**\n * Returns list of selector/property ranges for balancing for given code\n */\nexport function balanceCSS(code: string, pos: number, inward?: boolean) {\n    return inward\n        ? cssBalancedInward(code, pos)\n        : cssBalancedOutward(code, pos);\n}\n\n/**\n * Returns model for selecting next/previous item\n */\nexport function selectItem(code: string, pos: number, isCSS?: boolean, isPrevious?: boolean) {\n    return isCSS\n        ? selectItemCSS(code, pos, isPrevious)\n        : selectItemHTML(code, pos, isPrevious);\n}\n\n/**\n * Finds and evaluates math expression at given position in line\n */\nexport function evaluateMath(code: string, pos: number, options?: Partial<MathExtractOptions>): EvaluatedMath | undefined {\n    const expr = extractMath(code, pos, options);\n    if (expr) {\n        try {\n            const [start, end] = expr;\n            const result = evaluate(code.slice(start, end));\n            if (result) {\n                return {\n                    start, end, result,\n                    snippet: result.toFixed(4).replace(/\\.?0+$/, '')\n                };\n            }\n        } catch (err) {\n            console.error(err);\n        }\n    }\n}\n\n/**\n * Returns matched HTML/XML tag for given point in view\n */\nexport function getTagContext(editor: CodeMirror.Editor, pos: number, xml?: boolean): ContextTag | undefined {\n    const content = getContent(editor);\n    let ctx: ContextTag | undefined;\n\n    if (xml == null) {\n        // Autodetect XML dialect\n        const mode = editor.getMode();\n        xml = mode ? isXML(mode.name) : false;\n    }\n\n    const matchedTag = match(content, pos, { xml });\n    if (matchedTag) {\n        const { open, close } = matchedTag;\n        ctx = {\n            name: matchedTag.name,\n            open,\n            close\n        };\n\n        if (matchedTag.attributes) {\n            ctx.attributes = {};\n            matchedTag.attributes.forEach(attr => {\n                let value = attr.value;\n                if (value && isQuotedString(value)) {\n                    value = value.slice(1, -1);\n                }\n\n                ctx!.attributes![attr.name] = value == null ? null : value;\n            });\n        }\n    }\n\n    return ctx;\n}\n\n/**\n * Returns Emmet options for given character location in editor\n */\nexport function getOptions(editor: CodeMirror.Editor, pos: number): UserConfig {\n    const info = syntaxInfo(editor, pos);\n    const { context } = info;\n\n    const config: UserConfig = {\n        type: info.type,\n        syntax: info.syntax || 'html',\n        options: getOutputOptions(editor, pos, info.inline)\n    };\n\n    if (context) {\n        const content = getContent(editor);\n        // Set context from syntax info\n        if (context.type === 'html' && context.ancestors.length) {\n            config.context = getMarkupAbbreviationContext(content, context);\n        } else if (context.type === 'css') {\n            config.context = getStylesheetAbbreviationContext(context);\n        }\n    }\n\n    return config;\n}\n","import { UserConfig } from 'emmet';\nimport { AbbreviationTrackingController, EditorProxy, AbbreviationTracker, AbbreviationTrackerType, JSX_PREFIX, StopTrackingParams, StartTrackingParams } from '@emmetio/action-utils';\nimport { getInternalState, getCaret, toRange, errorSnippet, replaceWithSnippet } from './lib/utils';\nimport {\n    isSupported, isJSX, isCSS, isHTML, isXML, syntaxFromPos, docSyntax,\n    syntaxInfo, enabledForSyntax, getSyntaxType\n} from './lib/syntax';\nimport { getOptions, extract, expand } from './lib/emmet';\nimport getOutputOptions from './lib/output';\nimport getEmmetConfig from './lib/config';\n\nexport interface CompletionItem {\n    text: string;\n    displayText: string;\n    hint(): void;\n    from: CodeMirror.Position;\n    to: CodeMirror.Position;\n}\n\n/** Class name for Emmet abbreviation marker in editor */\nconst markClass = 'emmet-abbreviation';\n\n/** Class name for Emmet abbreviation preview in editor */\nconst previewClass = 'emmet-abbreviation-preview';\n\nclass CMEditorProxy implements EditorProxy {\n    public cm: CodeMirror.Editor;\n    public marker: CodeMirror.TextMarker | null = null;\n    public preview: CodeMirror.Editor | null = null;\n    public forcedMarker: HTMLElement | null = null;\n\n    get id() {\n        return getInternalState(this.cm).id;\n    }\n\n    substr(from?: number, to?: number) {\n        const value = this.cm.getValue();\n        if (from === undefined && to === undefined) {\n            return value;\n        }\n\n        return value.slice(from || 0, to);\n    }\n\n    replace(value: string, from: number, to: number) {\n        this.cm.replaceRange(value,\n            this.cm.posFromIndex(from),\n            this.cm.posFromIndex(to));\n    }\n\n    syntax() {\n        return docSyntax(this.cm);\n    }\n\n    size() {\n        return this.cm.getValue().length;\n    }\n\n    config(pos: number): UserConfig {\n        return getOptions(this.cm, pos);\n    }\n\n    outputOptions(pos: number, inline?: boolean) {\n        return getOutputOptions(this.cm, pos, inline);\n    }\n\n    previewConfig(config: UserConfig) {\n        return {\n            ...config,\n            options: {\n                ...config.options,\n                'output.field': previewField,\n                'output.indent': '  ',\n                'output.baseIndent': ''\n            }\n        };\n    }\n\n    allowTracking(pos: number) {\n        return allowTracking(this.cm, pos);\n    }\n\n    mark(tracker: AbbreviationTracker): void {\n        const { cm } = this;\n        this.disposeMarker();\n        const [from, to] = toRange(cm, tracker.range);\n        this.marker = cm.markText(from, to, {\n            inclusiveLeft: true,\n            inclusiveRight: true,\n            clearWhenEmpty: false,\n            className: markClass\n        });\n\n        if (tracker.forced && !this.forcedMarker) {\n            this.forcedMarker = document.createElement('div');\n            this.forcedMarker.className = `${markClass}-marker`;\n            cm.addWidget(from, this.forcedMarker, false);\n        }\n    }\n\n    unmark(): void {\n        this.disposeMarker();\n        this.hidePreview();\n    }\n\n    showPreview(tracker: AbbreviationTracker) {\n        const { cm } = this;\n        const config = getEmmetConfig(cm);\n\n        // Check if we should display preview\n        if (!enabledForSyntax(config.preview, syntaxInfo(cm, tracker.range[0]))) {\n            return;\n        }\n\n        let content: string | undefined;\n        let isError = false;\n\n        if (tracker.type === AbbreviationTrackerType.Error) {\n            content = errorSnippet(tracker.error);\n            isError = true;\n        } else if (tracker.forced || !tracker.simple) {\n            content = tracker.preview;\n        }\n\n        if (content) {\n            if (!this.preview) {\n                const previewElem = document.createElement('div');\n                previewElem.className = previewClass;\n\n                const pos = cm.posFromIndex(tracker.range[0]);\n                if (config.attachPreview) {\n                    config.attachPreview(cm, previewElem, pos);\n                } else {\n                    cm.addWidget(pos, previewElem, false);\n                }\n\n                // @ts-ignore\n                this.preview = new this.cm.constructor(previewElem, {\n                    mode: cm.getOption('mode'),\n                    readOnly: 'nocursor',\n                    lineNumbers: false\n                }) as CodeMirror.Editor;\n\n                const errElement = document.createElement('div');\n                errElement.className = `${previewClass}-error`;\n                previewElem.appendChild(errElement);\n            }\n\n            const wrapper = this.preview.getWrapperElement().parentElement!;\n            wrapper.classList.toggle('has-error', isError);\n            if (isError) {\n                wrapper.querySelector(`.${previewClass}-error`)!.innerHTML = content;\n            } else {\n                this.preview.setValue(content);\n            }\n        } else {\n            this.hidePreview();\n        }\n    }\n\n    hidePreview() {\n        if (this.preview) {\n            this.preview.getWrapperElement().parentElement!.remove();\n            this.preview = null;\n        }\n    }\n\n    /**\n     * Check if given syntax is a CSS dialect (including SCSS, LESS etc)\n     */\n    isCSS(syntax: string): boolean {\n        return isCSS(syntax);\n    }\n\n    syntaxType(syntax: string) {\n        return getSyntaxType(syntax);\n    }\n\n    /**\n     * Check if given syntax is a HTML dialect. HTML dialects also support embedded\n     * stylesheets in `<style>` tga or `style=\"\"` attribute\n     */\n    isHTML(syntax: string): boolean {\n        return isHTML(syntax);\n    }\n\n    /**\n     * Check if given syntax is a XML dialect. Unlike HTML, XML dialects doesn’t\n     * support embedded stylesheets\n     */\n    isXML(syntax: string): boolean {\n        return isXML(syntax);\n    }\n\n    /**\n     * Check if given syntax is a JSX dialect\n     */\n    isJSX(syntax: string) {\n        return isJSX(syntax);\n    }\n\n    /**\n     * Runs given callback in context of given editor\n     */\n    run<R>(editor: CodeMirror.Editor, callback: () => R): R {\n        const { cm } = this;\n        this.cm = editor;\n        const result = callback();\n        this.cm = cm;\n        return result;\n    }\n\n    private disposeMarker() {\n        if (this.marker) {\n            this.marker.clear();\n            this.marker = null;\n        }\n\n        if (this.forcedMarker) {\n            this.forcedMarker.remove();\n            this.forcedMarker = null;\n        }\n    }\n}\n\nfunction previewField(index: number, placeholder: string) {\n    return placeholder;\n}\n\nconst proxy = new CMEditorProxy();\nconst controller = new AbbreviationTrackingController<CMEditorProxy>();\n\nexport default function initAbbreviationTracker(editor: CodeMirror.Editor) {\n    const onChange = (ed: CodeMirror.Editor) => {\n        proxy.run(ed, () => {\n            controller.handleChange(proxy, getCaret(ed));\n        });\n    };\n    const onSelectionChange = (ed: CodeMirror.Editor) => {\n        proxy.run(ed, () => {\n            const caret = getCaret(ed);\n            if (!isEnabled(ed, caret)) {\n                return;\n            }\n\n            const tracker = controller.handleSelectionChange(proxy, caret);\n            if (tracker) {\n                if (contains(tracker, caret)) {\n                    proxy.showPreview(tracker);\n                } else {\n                    proxy.hidePreview();\n                }\n            }\n        });\n    };\n\n    editor.on('change', onChange);\n    editor.on('focus', onSelectionChange);\n    editor.on('cursorActivity', onSelectionChange);\n\n    return () => {\n        proxy.run(editor, () => controller.disposeEditor(proxy));\n        editor.off('change', onChange);\n        editor.off('focus', onSelectionChange);\n        editor.off('cursorActivity', onSelectionChange);\n    };\n}\n\n/**\n * Runs given function in context of abbreviation tracker\n */\nexport function runInTrackerContext<R>(editor: CodeMirror.Editor, callback: (controller: AbbreviationTrackingController<CMEditorProxy>, proxy: CMEditorProxy) => R): R {\n    return proxy.run(editor, () => callback(controller, proxy));\n}\n\n/**\n * Check if abbreviation tracking is allowed in editor at given location\n */\nexport function allowTracking(editor: CodeMirror.Editor, pos: number): boolean {\n    if (isEnabled(editor, pos)) {\n        const syntax = syntaxFromPos(editor, pos);\n        return syntax ? isSupported(syntax) || isJSX(syntax) : false;\n    }\n\n    return false;\n}\n\n/**\n * Check if Emmet auto-complete is enabled\n */\nexport function isEnabled(editor: CodeMirror.Editor, pos: number): boolean {\n    const config = getEmmetConfig(editor);\n    return enabledForSyntax(config.mark, syntaxInfo(editor, pos));\n}\n\n/**\n * If allowed, tries to extract abbreviation from given completion context\n */\nexport function extractTracker(editor: CodeMirror.Editor, pos: number): AbbreviationTracker | undefined {\n    return proxy.run(editor, () => {\n        const syntax = proxy.syntax();\n        const prefix = proxy.isJSX(syntax) ? JSX_PREFIX : '';\n        const config = controller.getActivationContext(proxy, pos);\n        const abbr = extract(proxy.substr(), pos, getSyntaxType(config?.syntax), { prefix });\n        if (abbr) {\n            const tracker = controller.startTracking(proxy, abbr.start, abbr.end, {\n                offset: prefix.length,\n                config\n            });\n\n            if (tracker) {\n                proxy.showPreview(tracker);\n            }\n            return tracker;\n        }\n    });\n}\n\n/**\n * Returns abbreviation tracker for given editor, if any\n */\nexport function getTracker(editor: CodeMirror.Editor): AbbreviationTracker | undefined {\n    return proxy.run(editor, () => controller.getTracker(proxy));\n}\n\n/**\n * Start abbreviation tracking in given editor for given range\n */\nexport function startTracking(editor: CodeMirror.Editor, start: number, pos: number, params?: Partial<StartTrackingParams>) {\n    return proxy.run(editor, () => {\n        const tracker = controller.startTracking(proxy, start, pos, params);\n        if (tracker) {\n            proxy.showPreview(tracker);\n        }\n\n        return tracker;\n    });\n}\n\n/**\n * Stops abbreviation tracking in given editor\n */\nexport function stopTracking(editor: CodeMirror.Editor, params?: Partial<StopTrackingParams>) {\n    return proxy.run(editor, () => controller.stopTracking(proxy, params));\n}\n\n/**\n * Returns completion item, suitable for auto-hint CodeMirror module,\n * with tracked abbreviation for it\n */\nexport function getCompletion(editor: CodeMirror.Editor, pos: number): CompletionItem | undefined {\n    const tracker = getTracker(editor) || extractTracker(editor, pos);\n    if (tracker && contains(tracker, pos) && tracker.type === AbbreviationTrackerType.Abbreviation) {\n        const { abbreviation, preview } = tracker;\n        return {\n            text: abbreviation,\n            displayText: preview,\n            hint: () => {\n                stopTracking(editor);\n                const snippet = expand(editor, abbreviation, tracker.config);\n                replaceWithSnippet(editor, tracker.range, snippet);\n            },\n            from: editor.posFromIndex(tracker.range[0]),\n            to: editor.posFromIndex(tracker.range[1]),\n        } as CompletionItem;\n    }\n}\n\n/**\n * Restore tracker on undo, if possible\n */\nexport function restoreOnUndo(editor: CodeMirror.Editor, pos: number, abbr: string) {\n    proxy.run(editor, () => {\n        const lastTracker = controller.getStoredTracker(proxy);\n\n        if (lastTracker) {\n            const shouldRestore = lastTracker.type === AbbreviationTrackerType.Abbreviation\n                && abbr === lastTracker.abbreviation\n                && lastTracker.range[0] === pos;\n\n            if (shouldRestore) {\n                controller.restoreTracker(proxy, pos);\n            }\n        }\n    })\n}\n\n/**\n * Check if tracker range contains given position\n */\nexport function contains(tracker: AbbreviationTracker, pos: number): boolean {\n    return pos >= tracker.range[0] && pos <= tracker.range[1];\n}\n","import { attributes } from '@emmetio/html-matcher';\nimport { TagMatch, findTagMatch, getTagMatches } from '@emmetio/action-utils';\nimport { getCaret, rangesEqual, substr, isQuotedString } from './utils';\nimport getEmmetConfig from './config';\n\nconst openTagMark = 'emmet-open-tag';\nconst closeTagMark = 'emmet-close-tag';\n\ninterface CMTagMatch extends TagMatch {\n    /** Open tag name preview */\n    preview?: string;\n}\n\ninterface CMMarkRange {\n    from: CodeMirror.Position;\n    to: CodeMirror.Position;\n}\n\n/**\n * Setup editor for tag matching\n */\nexport default function markTagMatches(editor: CodeMirror.Editor) {\n    let tags: TagMatch[] | null = null;\n    let lastMatch: TagMatch | null | undefined;\n    let tagPreview: HTMLElement | null = null;\n\n    /**\n     * Displays tag preview as given location, if possible\n     */\n    function showTagPreview(ed: CodeMirror.Editor, pos: number, preview: string) {\n        // Check if we already have preview at given location\n        if (!tagPreview || tagPreview.dataset.pos !== String(pos)) {\n            hidePreview();\n            tagPreview = createPreviewWidget(ed, pos, preview);\n        }\n    }\n\n    function hidePreview() {\n        if (tagPreview) {\n            tagPreview.remove();\n            tagPreview = null;\n        }\n    }\n\n    const onCursorActivity = (ed: CodeMirror.Editor) => {\n        if (!tags) {\n            tags = getTagMatches(ed.getValue());\n        }\n\n        const caret = getCaret(ed);\n        let match = findTagMatch(tags!, caret) as CMTagMatch | undefined;\n        if (match) {\n            if (!match.preview) {\n                match.preview = generatePreview(ed, match);\n            }\n\n            if (shouldDisplayTagPreview(ed, match, caret)) {\n                showTagPreview(ed, match.close![1], match.preview);\n            } else {\n                hidePreview();\n            }\n\n            // Replace full tag match with name-only match\n            const nLen = match.name.length;\n            match = {\n                ...match,\n                open: [match.open[0] + 1, match.open[0] + 1 + nLen],\n            };\n            if (match.close) {\n                match.close = [match.close[0] + 2, match.close[0] + 2 + nLen]\n            }\n        }\n\n        if (match && (!lastMatch || !rangesEqual(lastMatch.open, match.open))) {\n            clearTagMarks(ed);\n            markTagMatch(ed, match);\n        } else if (!match && lastMatch) {\n            clearTagMarks(ed);\n        }\n        lastMatch = match;\n    };\n\n    const onChange = (editor: CodeMirror.Editor) => {\n        tags = null;\n        if (getEmmetConfig(editor).autoRenameTags) {\n            const { open, close } = getTagMarks(editor);\n            if (open && close) {\n                const cursor = editor.getCursor();\n                const openRange = open.find();\n                const closeRange = close.find();\n                let shouldReset = false;\n\n                if (containsPos(openRange, cursor)) {\n                    // Update happened inside open tag, update close tag as well\n                    shouldReset = updateTag(editor, openRange, closeRange);\n                } else if (containsPos(closeRange, cursor)) {\n                    // Update happened inside close tag, update open tag as well\n                    shouldReset = updateTag(editor, closeRange, openRange);\n                }\n\n                if (shouldReset) {\n                    // Reset last match & marker to find and re-mark new location\n                    clearTagMarks(editor);\n                    lastMatch = null;\n                }\n            }\n        }\n    }\n\n    editor.on('cursorActivity', onCursorActivity);\n    editor.on('change', onChange);\n\n    return () => {\n        clearTagMarks(editor);\n        hidePreview();\n        editor.off('cursorActivity', onCursorActivity);\n        editor.off('cursorActivity', onChange);\n        tags = lastMatch = null;\n    };\n}\n\nfunction shouldDisplayTagPreview(editor: CodeMirror.Editor, match: CMTagMatch, caret: number) {\n    return match.close && match.preview && getEmmetConfig(editor).previewOpenTag\n        && caret > match.close[0] && caret < match.close[1];\n}\n\n/**\n * Marks given tag match in editor\n */\nfunction markTagMatch(editor: CodeMirror.Editor, { open, close, preview }: CMTagMatch) {\n    createTagMark(editor, editor.posFromIndex(open[0]), editor.posFromIndex(open[1]), openTagMark);\n    if (close) {\n        createTagMark(editor, editor.posFromIndex(close[0]), editor.posFromIndex(close[1]), closeTagMark);\n    }\n}\n\n/**\n * Removes any existing tag marks in editor\n */\nfunction clearTagMarks(editor: CodeMirror.Editor) {\n    const { open, close } = getTagMarks(editor);\n    open && open.clear();\n    close && close.clear();\n}\n\n/**\n * Returns open and close tag marks in editor, if available\n */\nfunction getTagMarks(editor: CodeMirror.Editor) {\n    let open: CodeMirror.TextMarker | undefined;\n    let close: CodeMirror.TextMarker | undefined;\n    editor.getAllMarks().forEach(mark => {\n        if (mark['className'] === openTagMark) {\n            open = mark;\n        } else if (mark['className'] === closeTagMark) {\n            close = mark;\n        }\n    });\n\n    return { open, close };\n}\n\nfunction createTagMark(editor: CodeMirror.Editor, from: CodeMirror.Position, to: CodeMirror.Position, className: string, attributes?: {}) {\n    return editor.markText(from, to, {\n        className,\n        inclusiveLeft: true,\n        inclusiveRight: true,\n        clearWhenEmpty: false,\n        // @ts-ignore `attributes` key is supported\n        attributes\n    });\n}\n\n/**\n * Updates content of `dest` range with valid tag name from `source` range.\n * @returns `true` if tag markers must be updated\n */\nfunction updateTag(editor: CodeMirror.Editor, source: CMMarkRange, dest: CMMarkRange): boolean {\n    const name = editor.getRange(source.from, source.to);\n    const m = name.match(/[\\w:.-]+/);\n    const newName = m ? m[0] : '';\n\n    if (editor.getRange(dest.from, dest.to) !== newName) {\n        editor.replaceRange(newName, dest.from, dest.to);\n    }\n\n    return name !== newName;\n}\n\nfunction createPreviewWidget(editor: CodeMirror.Editor, pos: number, preview: string): HTMLElement {\n    const elem = document.createElement('div');\n    elem.className = 'emmet-tag-preview';\n    elem.innerText = preview;\n    elem.dataset.pos = String(pos);\n\n    editor.addWidget(editor.posFromIndex(pos), elem, false);\n    return elem;\n}\n\n/**\n * Generates open tag preview for given tag match\n */\nfunction generatePreview(editor: CodeMirror.Editor, match: TagMatch): string {\n    let className = '';\n    let id = '';\n    const attrs: string[] = [];\n\n    attributes(substr(editor, match.open), match.name).forEach(attr => {\n        if (attr.name === 'class' && attr.value) {\n            className = '.' + unquoted(attr.value).replace(/\\s+/g, '.');\n        } else if (attr.name === 'id' && attr.value) {\n            id = '#' + unquoted(attr.value);\n        } else {\n            attrs.push(attr.value ? `${attr.name}=${attr.value}` : attr.name);\n        }\n    });\n\n    const attrString = attrs.length ? `[${attrs.join(' ')}]` : '';\n    const suffix = id + className + attrString;\n    return suffix ? match.name + suffix : '';\n}\n\nfunction unquoted(str: string) {\n    return isQuotedString(str) ? str.slice(1, -1) : str;\n}\n\n/**\n * Check if given range contains point\n * @param exclude Exclude range end and start\n */\nfunction containsPos(range: CMMarkRange, pos: CodeMirror.Position, exclude?: boolean): boolean {\n    return exclude\n        ? comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0\n        : comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;\n}\n\nfunction comparePos(a: CodeMirror.Position, b: CodeMirror.Position) {\n    return a.line - b.line || a.ch - b.ch;\n}\n","import Scanner from '@emmetio/scanner';\n\nexport type ParseModeError = Error & { ch?: number };\n\ninterface State {\n    parseError?: ParseModeError;\n}\n\nexport function error(message: string, scanner: Scanner | CodeMirror.StringStream): ParseModeError {\n    const err = new Error(message) as ParseModeError;\n    err.ch = scanner.pos;\n    return err;\n}\n\nexport function unexpectedCharacter(stream: CodeMirror.StringStream, state: State, message = 'Unexpected character'): string {\n    state.parseError = error(message.replace(/\\s+at\\s+\\d+$/, ''), stream);\n    stream.skipToEnd();\n    return 'invalidchar';\n}\n\nexport function last<T>(arr: T[]): T {\n    return arr[arr.length - 1];\n}\n","import Scanner from '@emmetio/scanner';\nimport { getToken, BracketType, Bracket, AllTokens } from '@emmetio/abbreviation';\nimport { last, unexpectedCharacter, error, ParseModeError } from './utils';\n\ntype Context = { [ctx in BracketType]: number } & { quote: number };\n\ninterface EmmetMarkupModeState extends Context {\n    parseError?: ParseModeError;\n    braces: Bracket[];\n    scanner: Scanner;\n    tokens: AllTokens[];\n}\n\nexport default function emmetAbbreviationMode(): CodeMirror.Mode<EmmetMarkupModeState> {\n    return {\n        startState() {\n            return {\n                attribute: 0,\n                expression: 0,\n                group: 0,\n                quote: 0,\n                braces: [],\n                tokens: [],\n                scanner: new Scanner('')\n            };\n        },\n        token(stream, state) {\n            const { scanner } = state;\n            scanner.string = stream.string;\n            scanner.pos = stream.pos;\n            scanner.start = stream.start;\n            scanner.end = stream.string.length;\n\n            const ch = scanner.peek();\n            const token = getToken(scanner, state);\n\n            if (!token) {\n                return unexpectedCharacter(stream, state);\n            }\n\n            stream.pos = scanner.pos;\n\n            if (token.type === 'Quote') {\n                state.quote = ch === state.quote ? 0 : ch;\n            } else if (token.type === 'Bracket') {\n                if (token.open) {\n                    state[token.context]++;\n                    state.braces.push(token);\n                } else {\n                    state[token.context]--;\n                    const lastBrace = last(state.braces);\n                    if (lastBrace && lastBrace.context === token.context) {\n                        state.braces.pop();\n                    }\n                }\n            }\n\n            // Report if closing braces are missing at the end of abbreviation\n            if (stream.eol() && state.braces.length && !state.parseError) {\n                const pos = last(state.braces).start;\n                state.parseError = error(`No closing brace at ${pos}`, stream);\n                return null;\n            }\n\n            const name = getTokenName(token, state);\n            state.tokens.push(token);\n            return name;\n        }\n    }\n}\n\n/**\n * Returns scope name for given token\n */\nfunction getTokenName(token: AllTokens, state: EmmetMarkupModeState): string {\n    const prev = last(state.tokens)\n    switch(token.type) {\n        case 'Bracket':\n            return `bracket`;\n        case 'Field':\n            return 'variable-2';\n        case 'Literal':\n            if (state.attribute) {\n                if (prev && prev.type === 'Operator' && prev.operator === 'equal') {\n                    return 'string-2';\n                }\n                return state.quote ? 'string' : 'attribute';\n            }\n\n            if (state.quote) {\n                return 'string';\n            }\n\n            if (prev && prev.type === 'Operator') {\n                if (prev.operator === 'class') {\n                    return 'variable-2';\n                }\n\n                if (prev.operator === 'id') {\n                    return 'variable-3';\n                }\n            }\n\n            return 'tag';\n        case 'Operator':\n            if (token.operator === 'class') {\n                return 'variable-2';\n            }\n\n            if (token.operator === 'id') {\n                return 'variable-3';\n            }\n\n            return `operator ${token.operator}`;\n        case 'Repeater':\n        case 'RepeaterPlaceholder':\n            return 'meta';\n        case 'Quote':\n            return 'string';\n        case 'RepeaterNumber':\n            return 'number';\n    }\n\n    return '';\n}\n","import Scanner from '@emmetio/scanner';\nimport { getToken, AllTokens } from '@emmetio/css-abbreviation';\nimport { unexpectedCharacter, ParseModeError } from './utils';\n\ninterface EmmetStylesheetModeState {\n    parseError?: ParseModeError;\n    brackets: number;\n    scanner: Scanner;\n    tokens: AllTokens[];\n}\n\nexport default function emmetAbbreviationMode(): CodeMirror.Mode<EmmetStylesheetModeState> {\n    return {\n        startState() {\n            return {\n                brackets: 0,\n                tokens: [],\n                scanner: new Scanner('')\n            };\n        },\n        token(stream, state) {\n            const { scanner } = state;\n            scanner.string = stream.string;\n            scanner.pos = stream.pos;\n            scanner.start = stream.start;\n            scanner.end = stream.string.length;\n\n            const token = getToken(scanner, state.brackets === 0);\n\n            if (!token) {\n                return unexpectedCharacter(stream, state);\n            }\n\n            if (token.type === 'Bracket') {\n                state.brackets += token.open ? 1 : -1;\n                if (state.brackets < 0) {\n                    return unexpectedCharacter(stream, state, 'Unexpected bracket');\n                }\n            }\n\n            stream.pos = scanner.pos;\n\n            const name = getTokenName(token, state);\n            state.tokens.push(token);\n            return name;\n        }\n    }\n}\n\n/**\n * Returns scope name for given token\n */\nfunction getTokenName(token: AllTokens, state: EmmetStylesheetModeState): string | null {\n    switch (token.type) {\n        case 'Bracket':\n            return `bracket`;\n        case 'Field':\n            return 'variable-2';\n        case 'Literal':\n            return 'tag';\n        case 'Operator':\n            return `operator ${token.operator}`;\n        case 'ColorValue':\n            return 'variable-3';\n        case 'NumberValue':\n            return 'number';\n        case 'StringValue':\n            return 'string';\n    }\n\n    return null;\n}\n","/**\n * Emmet snippet name parsing mode\n */\nexport default function snippetNameMode(): CodeMirror.Mode<{}> {\n    return {\n        token(stream) {\n            if (stream.eatWhile(ident)) {\n                return 'tag';\n            }\n\n            if (stream.eat(separator)) {\n                return 'operator';\n            }\n\n            stream.skipToEnd();\n            return 'invalidchar';\n        }\n    };\n}\n\nfunction ident(ch: string): boolean {\n    return /[a-zA-Z0-9-_$@!:]/.test(ch);\n}\n\nfunction separator(ch: string): boolean {\n    return ch === '|';\n}\n","import { UserConfig } from 'emmet';\nimport { TextRange, AbbreviationTrackerType } from '@emmetio/action-utils';\nimport { pass, getCaret, replaceWithSnippet } from '../lib/utils';\nimport getEmmetConfig from '../lib/config';\nimport { getTracker, stopTracking, contains, runInTrackerContext } from '../abbreviation';\nimport { expand, extract, getOptions } from '../lib/emmet';\nimport { getSyntaxType } from '../lib/syntax';\n// import { getActivationContext } from '../abbreviation';\n\nexport default function expandAbbreviation(editor: CodeMirror.Editor, tabKey?: boolean) {\n    if (editor.somethingSelected()) {\n        return pass(editor);\n    }\n\n    if (tabKey) {\n        return expandAbbreviationWithTab(editor);\n    }\n\n    const caret = getCaret(editor);\n    const pos = editor.posFromIndex(caret);\n    const line = editor.getLine(pos.line);\n    const options = getOptions(editor, caret);\n    const abbr = extract(line, pos.ch, getSyntaxType(options.syntax));\n\n    if (abbr) {\n        const offset = caret - pos.ch;\n        runExpand(editor, abbr.abbreviation, [abbr.start + offset, abbr.end + offset], options);\n    }\n}\n\nfunction expandAbbreviationWithTab(editor: CodeMirror.Editor) {\n    // With Tab key, we should either expand tracked abbreviation\n    // or extract abbreviation from current location if abbreviation marking\n    // is not available\n    const caret = getCaret(editor);\n    if (getEmmetConfig(editor).mark) {\n        const tracker = getTracker(editor);\n\n        if (tracker && contains(tracker, caret) && tracker.type === AbbreviationTrackerType.Abbreviation) {\n            runExpand(editor, tracker.abbreviation, tracker.range, tracker.config);\n            stopTracking(editor, { skipRemove: true });\n            return;\n        }\n        return pass(editor);\n    }\n\n    return runInTrackerContext(editor, (controller, proxy) => {\n        const options = controller.getActivationContext(proxy, caret);\n        if (options) {\n            const pos = editor.posFromIndex(caret);\n            const line = editor.getLine(pos.line);\n            const abbr = extract(line, pos.ch, getSyntaxType(options.syntax));\n            if (abbr) {\n                const offset = caret - pos.ch;\n                runExpand(editor, abbr.abbreviation, [abbr.start + offset, abbr.end + offset], options);\n                return;\n            }\n        }\n        return pass(editor);\n    });\n}\n\nfunction runExpand(editor: CodeMirror.Editor, abbr: string, range: TextRange, options?: UserConfig) {\n    const snippet = expand(editor, abbr, options);\n    replaceWithSnippet(editor, range, snippet);\n}\n","import { getTracker, stopTracking } from '../abbreviation';\nimport { pass } from '../lib/utils';\n\nexport default function resetAbbreviation(editor: CodeMirror.Editor) {\n    const tracker = getTracker(editor);\n    if (tracker) {\n        stopTracking(editor, { force: true });\n    } else {\n        return pass(editor);\n    }\n}\n","import { getCaret } from '../lib/utils';\nimport { extractTracker, stopTracking } from '../abbreviation';\n\nexport default function captureAbbreviation(editor: CodeMirror.Editor) {\n    stopTracking(editor);\n    extractTracker(editor, getCaret(editor));\n}\n","import { getTracker, stopTracking, startTracking } from '../abbreviation';\nimport { textRange } from '../lib/utils';\n\nexport default function enterAbbreviationMode(editor: CodeMirror.Editor) {\n    let tracker = getTracker(editor);\n    stopTracking(editor);\n    if (tracker && tracker.forced) {\n        // Already have forced abbreviation: act as toggler\n        return;\n    }\n\n    const [from, to] = textRange(editor, editor.listSelections()[0]);\n\n    tracker = startTracking(editor, from, to, { forced: true });\n    if (from !== to) {\n        editor.setSelection(editor.posFromIndex(to));\n    }\n}\n","import { pass } from '../lib/utils';\nimport { getIndentation, lineIndent } from '../lib/output';\n\ninterface Sel {\n    anchor: CodeMirror.Position;\n    head: CodeMirror.Position;\n}\n\nexport default function insertLineBreak(editor: CodeMirror.Editor) {\n    const between = editor.listSelections().map(sel => betweenTags(editor, sel.anchor, sel.head));\n\n    if (!between.some(Boolean)) {\n        return pass(editor);\n    }\n\n    editor.operation(() => {\n        const sels = editor.listSelections();\n        // @ts-ignore Invalid docs for Document\n        const nl = editor.getDoc().lineSeparator();\n        const indent = getIndentation(editor);\n\n        // Step 1: insert newlines either single or double depending on selection\n        const nextSels: Sel[] = [];\n        for (let i = sels.length - 1; i >= 0; i--) {\n            const sel = sels[i];\n            const base = lineIndent(editor, sel.anchor.line);\n            let nextIndent = base;\n            if (between[i]) {\n                nextIndent += indent;\n                editor.replaceRange( nl + nextIndent + nl + base, sel.anchor, sel.head);\n            } else {\n                editor.replaceRange(nl + base, sel.anchor, sel.head);\n            }\n\n            const nextPos: CodeMirror.Position = {\n                line: sel.anchor.line + 1,\n                ch: nextIndent.length\n            };\n            nextSels.unshift({ anchor: nextPos, head: nextPos });\n        }\n\n        editor.setSelections(nextSels);\n    });\n}\n\n/**\n * Check if given range is a single caret between tags\n */\nfunction betweenTags(editor: CodeMirror.Editor, anchor: CodeMirror.Position, head: CodeMirror.Position) {\n    if (equalCursorPos(anchor, head)) {\n        const mode = editor.getModeAt(anchor);\n\n        if (mode.name === 'xml') {\n            const left = editor.getTokenAt(anchor);\n            const right = editor.getTokenAt(Object.assign({}, anchor, { ch: anchor.ch + 1 }));\n\n            return left.type === 'tag bracket' && left.string === '>'\n                && right.type === 'tag bracket' && right.string === '</';\n        }\n    }\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a: CodeMirror.Position, b: CodeMirror.Position) {\n    return a.line - b.line || a.ch - b.ch;\n}\n\nfunction equalCursorPos(a: CodeMirror.Position, b: CodeMirror.Position) {\n    return a.sticky === b.sticky && cmp(a, b) === 0;\n}\n","import { TextRange } from '@emmetio/action-utils';\nimport { getOptions, getTagContext, ContextTag, expand } from '../lib/emmet';\nimport { getCaret, narrowToNonSpace, replaceWithSnippet, substr, errorSnippet, textRange } from '../lib/utils';\nimport { docSyntax, isXML } from '../lib/syntax';\nimport { lineIndent } from '../lib/output';\n\nconst baseClass = 'emmet-panel';\nconst errClass = 'emmet-error';\n\nexport default function wrapWithAbbreviation(editor: CodeMirror.Editor) {\n    const syntax = docSyntax(editor);\n    const caret = getCaret(editor);\n    const context = getTagContext(editor, caret, isXML(syntax));\n    const wrapRange = getWrapRange(editor, getSelection(editor), context);\n    const options = getOptions(editor, wrapRange[0]);\n    options.text = getContent(editor, wrapRange, true);\n\n    let panel = createInputPanel();\n    let input = panel.querySelector('input')!;\n    let errContainer = panel.querySelector(`.${baseClass}-error`)!;\n    let updated = false;\n\n    function onInput(evt: InputEvent) {\n        evt && evt.stopPropagation();\n        undo();\n        const abbr = input.value.trim();\n        if (!abbr) {\n            return;\n        }\n\n        try {\n            const snippet = expand(editor, abbr, options);\n            replaceWithSnippet(editor, wrapRange, snippet);\n            updated = true;\n            if (panel.classList.contains(errClass)) {\n                errContainer.innerHTML = '';\n                panel.classList.remove(errClass);\n            }\n        } catch (err) {\n            updated = false;\n            panel.classList.add(errClass);\n            errContainer.innerHTML = errorSnippet(err);\n            console.error(err);\n        }\n    };\n\n    function onKeyDown(evt: KeyboardEvent) {\n        if (evt.keyCode === 27 /* ESC */) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            cancel();\n        } else if (evt.keyCode === 13 /* Enter */) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            submit();\n        }\n    };\n\n    function undo() {\n        if (updated) {\n            editor.undo();\n        }\n    }\n\n    function cancel() {\n        undo();\n        dispose();\n        editor.focus();\n    }\n\n    function submit() {\n        // Changes should already be applied to editor\n        dispose();\n        editor.focus();\n    }\n\n    function dispose() {\n        input.removeEventListener('input', onInput);\n        input.removeEventListener('change', onInput);\n        input.removeEventListener('paste', onInput);\n        input.removeEventListener('keydown', onKeyDown);\n        input.removeEventListener('blur', cancel);\n        panel.remove();\n        // @ts-ignore Dispose element references\n        panel = input = errContainer = null;\n    }\n\n    // Expose internals to programmatically submit or cancel command\n    panel['emmet'] = { submit, cancel, update: onInput };\n\n    input.addEventListener('input', onInput);\n    input.addEventListener('change', onInput);\n    input.addEventListener('paste', onInput);\n    input.addEventListener('keydown', onKeyDown);\n    editor.getWrapperElement().appendChild(panel);\n    input.focus();\n}\n\nfunction createInputPanel(): HTMLElement {\n    const elem = document.createElement('div');\n    elem.className = baseClass;\n    elem.innerHTML = `<div class=\"${baseClass}-wrapper\">\n        <input type=\"text\" placeholder=\"Enter abbreviation\" autofocus />\n        <div class=\"${baseClass}-error\"></div>\n    </div>`;\n    return elem;\n}\n\nfunction getWrapRange(editor: CodeMirror.Editor, range: TextRange, context?: ContextTag): TextRange {\n    if (range[0] === range[1] && context) {\n        // No selection means user wants to wrap current tag container\n        const { open, close } = context;\n        const pos = range[0];\n\n        // Check how given point relates to matched tag:\n        // if it's in either open or close tag, we should wrap tag itself,\n        // otherwise we should wrap its contents\n\n        if (inRange(open, pos) || (close && inRange(close, pos))) {\n            return [open[0], close ? close[1] : open[1]];\n        }\n\n        if (close) {\n            return narrowToNonSpace(editor, [open[1], close[0]]);\n        }\n    }\n\n    return range;\n}\n\n/**\n * Returns contents of given region, properly de-indented\n */\nfunction getContent(editor: CodeMirror.Editor, range: TextRange, lines = false): string | string[] {\n    const pos = editor.posFromIndex(range[0]);\n    const baseIndent = lineIndent(editor, pos.line);\n    const srcLines = substr(editor, range).split('\\n');\n    const destLines = srcLines.map(line => {\n        return line.startsWith(baseIndent)\n            ? line.slice(baseIndent.length)\n            : line;\n    });\n\n    return lines ? destLines : destLines.join('\\n');\n}\n\nfunction inRange(range: TextRange, pt: number): boolean {\n    return range[0] < pt && pt < range[1];\n}\n\nfunction getSelection(editor: CodeMirror.Editor): TextRange {\n    return textRange(editor, editor.listSelections()[0]);\n}\n","import { TextRange } from '@emmetio/action-utils';\nimport { isCSS, isXML, docSyntax, isHTML } from '../lib/syntax';\nimport { balanceCSS, balance } from '../lib/emmet';\nimport { getContent, textRange, rangeContains, rangesEqual, pass } from '../lib/utils';\n\nexport default function balanceAction(editor: CodeMirror.Editor, inward?: boolean) {\n    const syntax = docSyntax(editor);\n\n    if (isHTML(syntax) || isCSS(syntax)) {\n        const ranges = inward\n            ? balanceActionInward(editor, syntax)\n            : balanceActionOutward(editor, syntax);\n\n        editor.setSelections(ranges.map(r => ({\n            anchor: editor.posFromIndex(r[0]),\n            head: editor.posFromIndex(r[1]),\n        })));\n    } else {\n        return pass(editor);\n    }\n}\n\n/**\n * Pushes given `range` into `ranges` list on if it’s not the same as last one\n */\nfunction pushRange(ranges: TextRange[], range: TextRange) {\n    const last = ranges[ranges.length - 1];\n    if (!last || !rangesEqual(last, range)) {\n        ranges.push(range);\n    }\n}\n\n/**\n * Returns regions for balancing\n */\nfunction getRanges(editor: CodeMirror.Editor, pos: number, syntax: string, inward?: boolean): TextRange[] {\n    const content = getContent(editor);\n    if (isCSS(syntax)) {\n        return balanceCSS(content, pos, inward);\n    }\n\n    const result: TextRange[] = [];\n    const tags = balance(content, pos, inward, isXML(syntax));\n\n    for (const tag of tags) {\n        if (tag.close) {\n            // Inner range\n            pushRange(result, [tag.open[1], tag.close[0]]);\n            // Outer range\n            pushRange(result, [tag.open[0], tag.close[1]]);\n        } else {\n            pushRange(result, [tag.open[0], tag.open[1]]);\n        }\n    }\n\n    return result.sort((a, b) => {\n        return inward ? a[0] - b[0] : b[0] - a[0];\n    });\n}\n\n/**\n * Returns inward balanced ranges from current view's selection\n */\nfunction balanceActionInward(editor: CodeMirror.Editor, syntax: string): TextRange[] {\n    const result: TextRange[] = [];\n\n    for (const sel of editor.listSelections()) {\n        const selRange = textRange(editor, sel);\n        const ranges = getRanges(editor, selRange[0], syntax, true);\n\n        // Try to find range which equals to selection: we should pick leftmost\n        let ix = ranges.findIndex(r => rangesEqual(selRange, r));\n        let targetRange: TextRange | undefined;\n\n        if (ix < ranges.length - 1) {\n            targetRange = ranges[ix + 1];\n        } else if (ix !== -1) {\n            // No match found, pick closest region\n            targetRange = ranges.find(r => rangeContains(r, selRange));\n        }\n\n        result.push(targetRange || selRange);\n    }\n\n    return result;\n}\n\n/**\n * Returns outward balanced ranges from current view's selection\n */\nfunction balanceActionOutward(editor: CodeMirror.Editor, syntax: string): TextRange[] {\n    const result: TextRange[] = [];\n    for (const sel of editor.listSelections()) {\n        const selRange = textRange(editor, sel);\n        const ranges = getRanges(editor, selRange[0], syntax);\n        const targetRange = ranges.find(r => rangeContains(r, selRange) && r[1] > selRange[1]);\n        result.push(targetRange || selRange);\n    }\n\n    return result;\n}\n\n","import Scanner from '@emmetio/scanner';\nimport { scan, createOptions, ElementType, ScannerOptions } from '@emmetio/html-matcher';\nimport matchCSS from '@emmetio/css-matcher';\nimport { TextRange } from '@emmetio/action-utils';\nimport { isSpace, getContent, narrowToNonSpace, textRange, rangeEmpty, substr, toRange } from '../lib/utils';\nimport { isHTML, isXML, isCSS, syntaxInfo } from '../lib/syntax';\n\ninterface Block {\n    range: TextRange;\n    commentStart?: string;\n    commentEnd?: string;\n}\n\ninterface Tag {\n    name: string;\n    start: number;\n    end: number;\n}\n\ntype CommentTokens = [string, string];\n\nconst htmlComment: CommentTokens = ['<!--', '-->'];\nconst cssComment: CommentTokens = ['/*', '*/'];\n\nexport default function comment(editor: CodeMirror.Editor) {\n    const selection = editor.listSelections().slice().reverse();\n    editor.operation(() => {\n        for (const sel of selection) {\n            const selRange = textRange(editor, sel);\n            const { syntax } = syntaxInfo(editor, selRange[0]);\n            const tokens = syntax && isCSS(syntax) ? cssComment : htmlComment;\n            const block = getRangeForComment(editor, selRange[0]);\n\n            if (block && block.commentStart) {\n                // Caret inside comment, strip it\n                removeComment(editor, block);\n            } else if (block && rangeEmpty(selRange)) {\n                // Wrap block with comments but remove inner comments first\n                let removed = 0;\n                for (const c of getCommentRegions(editor, block.range, tokens).reverse()) {\n                    removed += removeComment(editor, c);\n                }\n\n                addComment(editor, [block.range[0], block.range[1] - removed], tokens);\n            } else if (!rangeEmpty(selRange)) {\n                // No matching block, comment selection\n                addComment(editor, selRange, tokens);\n            } else {\n                // No matching block, comment line\n\n                const line = editor.getLine(sel.anchor.line);\n                const lineRange = textRange(editor, {\n                    anchor: { line: sel.anchor.line, ch: 0 },\n                    head: { line: sel.anchor.line, ch: line.length },\n                })\n                addComment(editor, narrowToNonSpace(editor, lineRange), tokens);\n            }\n        }\n    });\n}\n\n/**\n * Removes comment markers from given region. Returns amount of characters removed\n */\nfunction removeComment(editor: CodeMirror.Editor, { range, commentStart, commentEnd }: Block): number {\n    const text = substr(editor, range);\n\n    if (commentStart && text.startsWith(commentStart)) {\n        let startOffset = commentStart.length;\n        let endOffset = commentEnd && text.endsWith(commentEnd)\n            ? commentEnd.length\n            : 0;\n\n        // Narrow down offsets for whitespace\n        if (isSpace(text[startOffset])) {\n            startOffset += 1;\n        }\n\n        if (endOffset && isSpace(text[text.length - endOffset - 1])) {\n            endOffset += 1;\n        }\n\n        const r1 = toRange(editor, [range[1] - endOffset, range[1]]);\n        const r2 = toRange(editor, [range[0], range[0] + startOffset]);\n        editor.replaceRange('', r1[0], r1[1]);\n        editor.replaceRange('', r2[0], r2[1]);\n\n        return startOffset + endOffset;\n    }\n\n    return 0;\n}\n\n/**\n * Adds comments around given range\n */\nfunction addComment(editor: CodeMirror.Editor, range: TextRange, tokens: CommentTokens) {\n    const [from, to] = toRange(editor, range);\n    editor.replaceRange(' ' + tokens[1], to, to);\n    editor.replaceRange(tokens[0] + ' ', from, from);\n}\n\n/**\n * Finds comments inside given region and returns their regions\n */\nfunction getCommentRegions(editor: CodeMirror.Editor, range: TextRange, tokens: CommentTokens): Block[] {\n    const result: Block[] = [];\n    const text = substr(editor, range);\n    let start = range[0];\n    let offset = 0\n\n    while (true) {\n        const commentStart = text.indexOf(tokens[0], offset);\n        if (commentStart !== -1) {\n            offset = commentStart + tokens[0].length;\n\n            // Find comment end\n            const commentEnd = text.indexOf(tokens[1], offset);\n            if (commentEnd !== -1) {\n                offset = commentEnd + tokens[1].length;\n                result.push({\n                    range: [start + commentStart, start + offset],\n                    commentStart: tokens[0],\n                    commentEnd: tokens[1],\n                });\n            }\n        } else {\n            break;\n        }\n    }\n\n    return result;\n}\n\nfunction getRangeForComment(editor: CodeMirror.Editor, pos: number): Block | undefined {\n    const { syntax } = syntaxInfo(editor, pos);\n    if (!syntax) {\n        return;\n    }\n\n    if (isHTML(syntax)) {\n        return getHTMLBlockRange(getContent(editor), pos, isXML(syntax));\n    }\n\n    if (isCSS(syntax)) {\n        const content = getContent(editor);\n        const comment = findCSSComment(content, pos);\n        if (comment) {\n            return comment;\n        }\n\n        const css = matchCSS(content, pos);\n        if (css) {\n            return {\n                range: [css.start, css.end]\n            };\n        }\n    }\n}\n\n/**\n * Returns range for comment toggling\n */\nfunction getHTMLBlockRange(source: string, pos: number, xml = false): Block | undefined {\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool: Tag[] = [];\n    const stack: Tag[] = [];\n    const options = createOptions({ xml, allTokens: true });\n    let result: Block | undefined;\n\n    scan(source, (name, type, start, end) => {\n        if (type === ElementType.Open && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = ElementType.SelfClose;\n        }\n\n        if (type === ElementType.Open) {\n            // Allocate tag object from pool\n            stack.push(allocTag(pool, name, start, end));\n        } else if (type === ElementType.SelfClose) {\n            if (start < pos && pos < end) {\n                // Matched given self-closing tag\n                result = { range: [start, end] };\n                return false;\n            }\n        } else if (type === ElementType.Close) {\n            const tag = last(stack);\n            if (tag && tag.name === name) {\n                // Matching closing tag found\n                if (tag.start < pos && pos < end) {\n                    result = {\n                        range: [tag.start, end],\n                    };\n                    return false;\n                } else if (stack.length) {\n                    // Release tag object for further re-use\n                    releaseTag(pool, stack.pop()!);\n                }\n            }\n        } else if (start < pos && pos < end) {\n            // Found other token that matches given location\n            result = { range: [start, end] };\n            if (type === ElementType.Comment) {\n                result.commentStart = htmlComment[0];\n                result.commentEnd = htmlComment[1];\n            }\n            return false;\n        }\n    }, options);\n\n    stack.length = pool.length = 0;\n    return result;\n}\n\n/**\n * If given `pos` location is inside CSS comment in given `code`, returns its\n * range\n */\nfunction findCSSComment(code: string, pos: number): Block | undefined {\n    const enum Chars {\n        Asterisk = 42,\n        Slash = 47,\n        Backslash = 92,\n        LF = 10,\n        CR = 13,\n    };\n    const scanner = new Scanner(code);\n\n    while (!scanner.eof() && pos > scanner.pos) {\n        const start = scanner.pos;\n\n        if (consumeSeq2(scanner, Chars.Slash, Chars.Asterisk)) {\n            // Consumed multiline comment start\n            while (!scanner.eof() && !consumeSeq2(scanner, Chars.Asterisk, Chars.Slash)) {\n                scanner.pos++;\n            }\n\n            if (start < pos && pos < scanner.pos) {\n                return {\n                    range: [start, scanner.pos],\n                    commentStart: cssComment[0],\n                    commentEnd: cssComment[1],\n                };\n            }\n        } else if (consumeSeq2(scanner, Chars.Slash, Chars.Slash)) {\n            // Consumed single-line comment\n            while (!scanner.eof() && !scanner.eat(Chars.CR) && !scanner.eat(Chars.LF)) {\n                scanner.pos++;\n            }\n            if (start < pos && pos < scanner.pos) {\n                return {\n                    range: [start, scanner.pos],\n                    commentStart: '//',\n                };\n            }\n        } else {\n            scanner.pos++;\n        }\n    }\n}\n\n/**\n * Returns `true` if both `ch1` and `ch2` where consumed\n */\nfunction consumeSeq2(scanner: Scanner, ch1: number, ch2: number): boolean {\n    const { pos } = scanner;\n    if (scanner.eat(ch1) && scanner.eat(ch2)) {\n        return true;\n    }\n\n    scanner.pos = pos;\n    return false;\n}\n\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name: string, options: ScannerOptions) {\n    return !options.xml && options.empty.includes(name);\n}\n\nfunction allocTag(pool: Tag[], name: string, start: number, end: number): Tag {\n    if (pool.length) {\n        const tag = pool.pop()!;\n        tag.name = name;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, start, end };\n}\n\nfunction releaseTag(pool: Tag[], tag: Tag) {\n    pool.push(tag);\n}\n\nfunction last<T>(arr: T[]): T | null {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n","import { evaluateMath } from '../lib/emmet';\n\nexport default function evaluateMathCommand(editor: CodeMirror.Editor) {\n    const cursor = editor.getCursor();\n    const line = editor.getLine(cursor.line);\n    const expr = evaluateMath(line, cursor.ch);\n\n    if (expr) {\n        const from = { line: cursor.line, ch: expr.start };\n        const to = { line: cursor.line, ch: expr.end };\n        editor.replaceRange(expr.snippet, from, to);\n    }\n}\n","import { getContent, isQuote, isSpace, getCaret } from '../lib/utils';\n\nexport default function goToEditPoint(editor: CodeMirror.Editor, inc: number) {\n    const caret = getCaret(editor);\n    const pos = findNewEditPoint(editor, caret + inc, inc);\n    if (pos != null) {\n        editor.setCursor(editor.posFromIndex(pos));\n    }\n}\n\nfunction findNewEditPoint(editor: CodeMirror.Editor, pos: number, inc: number): number | undefined {\n    const doc = getContent(editor);\n    const docSize = doc.length;\n    let curPos = pos;\n\n    while (curPos < docSize && curPos >= 0) {\n        curPos += inc;\n        const cur = doc[curPos];\n        const next = doc[curPos + 1];\n        const prev = doc[curPos - 1];\n\n        if (isQuote(cur) && next === cur && prev === '=') {\n            // Empty attribute value\n            return curPos + 1;\n        }\n\n        if (cur === '<' && prev === '>') {\n            // Between tags\n            return curPos;\n        }\n\n        if (isNewLine(cur)) {\n            const pt = editor.posFromIndex(curPos);\n            const line = editor.getLine(pt.line);\n            if (!line || isSpace(line)) {\n                // Empty line\n                return editor.indexFromPos({\n                    line: pt.line,\n                    ch: line.length\n                });\n            }\n        }\n    }\n}\n\nfunction isNewLine(ch: string) {\n    return ch === '\\r' || ch === '\\n';\n}\n","import { TextRange } from '@emmetio/action-utils';\nimport { getCaret, substr } from '../lib/utils';\nimport { isHTML, isXML, syntaxInfo } from '../lib/syntax';\nimport { getTagContext } from '../lib/emmet';\n\nexport default function goToTagPair(editor: CodeMirror.Editor) {\n    let caret = getCaret(editor);\n    const nextRange: TextRange = [caret, Math.min(caret + 1, editor.getValue().length)];\n    if (substr(editor, nextRange) === '<') {\n        caret++;\n    }\n\n    const { syntax } = syntaxInfo(editor, caret);\n    if (isHTML(syntax)) {\n        const ctx = getTagContext(editor, caret, isXML(syntax));\n        if (ctx && ctx.open && ctx.close) {\n            const { open, close } = ctx;\n            const nextPos = open[0] <= caret && caret < open[1]\n                ? close[0]\n                : open[0];\n\n            editor.setCursor(editor.posFromIndex(nextPos));\n        }\n    }\n}\n","import { isNumber } from '@emmetio/scanner';\nimport { textRange, rangeEmpty, substr, replaceWithSnippet } from '../lib/utils';\n\nexport default function incrementNumber(editor: CodeMirror.Editor, delta = 1) {\n    editor.operation(() => {\n        const nextRanges = editor.listSelections().slice().reverse().map(sel => {\n            let selRange = textRange(editor, sel);\n            if (rangeEmpty(selRange)) {\n                // No selection, extract number\n                const line = editor.getLine(sel.anchor.line);\n                const offset = sel.anchor.ch;\n                const numRange = extractNumber(line, offset);\n                if (numRange) {\n                    selRange = [\n                        selRange[0] - offset + numRange[0],\n                        selRange[0] - offset + numRange[1],\n                    ]\n                }\n            }\n\n            if (!rangeEmpty(selRange)) {\n                // Try to update value in given region\n                let value = updateNumber(substr(editor, selRange), delta);\n                replaceWithSnippet(editor, selRange, value);\n                sel = {\n                    anchor: editor.posFromIndex(selRange[0]),\n                    head: editor.posFromIndex(selRange[0] + value.length)\n                };\n            }\n\n            return sel;\n        });\n\n        editor.setSelections(nextRanges);\n    });\n}\n\n/**\n * Extracts number from text at given location\n */\nfunction extractNumber(text: string, pos: number): [number, number] | undefined {\n    let hasDot = false;\n    let end = pos;\n    let start = pos;\n    let ch: number;\n    const len = text.length;\n\n    // Read ahead for possible numbers\n    while (end < len) {\n        ch = text.charCodeAt(end);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        end++;\n    }\n\n    // Read backward for possible numerics\n    while (start >= 0) {\n        ch = text.charCodeAt(start - 1);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        start--;\n    }\n\n    // Negative number?\n    if (start > 0 && text[start - 1] === '-') {\n        start--;\n    }\n\n    if (start !== end) {\n        return [start, end];\n    }\n}\n\nfunction updateNumber(num: string, delta: number, precision = 3): string {\n    const value = parseFloat(num) + delta;\n\n    if (isNaN(value)) {\n        return num;\n    }\n\n    const neg = value < 0;\n    let result = Math.abs(value).toFixed(precision);\n\n    // Trim trailing zeroes and optionally decimal number\n    result = result.replace(/\\.?0+$/, '');\n\n    // Trim leading zero if input value doesn't have it\n    if ((num[0] === '.' || num.startsWith('-.')) && result[0] === '0') {\n        result = result.slice(1);\n    }\n\n    return (neg ? '-' : '') + result;\n}\n\nfunction isDot(ch: number) {\n    return ch === 46;\n}\n","import { TextRange } from '@emmetio/action-utils';\nimport { getTagContext, ContextTag } from '../lib/emmet';\nimport { narrowToNonSpace, isSpace as isSpaceText, replaceWithSnippet, substr, rangeEmpty } from '../lib/utils';\nimport { lineIndent } from '../lib/output';\n\nexport default function removeTagCommand(editor: CodeMirror.Editor) {\n    editor.operation(() => {\n        const nextRanges = editor.listSelections().slice().reverse().map(sel => {\n            const tag = getTagContext(editor, editor.indexFromPos(sel.anchor));\n            if (tag) {\n                removeTag(editor, tag);\n                const pos = editor.posFromIndex(tag.open[0]);\n                return {\n                    anchor: pos,\n                    head: pos\n                };\n            }\n\n            return sel;\n        });\n\n        editor.setSelections(nextRanges);\n    });\n}\n\nfunction removeTag(editor: CodeMirror.Editor, { open, close }: ContextTag) {\n    if (close) {\n        // Remove open and close tag and dedent inner content\n        const innerRange = narrowToNonSpace(editor, [open[1], close[0]]);\n        if (!rangeEmpty(innerRange)) {\n            // Gracefully remove open and close tags and tweak indentation on tag contents\n            replaceWithSnippet(editor, [innerRange[1], close[1]], '');\n\n            const start = editor.posFromIndex(open[0]);\n            const end = editor.posFromIndex(close[1]);\n            if (start.line !== end.line) {\n                // Skip two lines: first one for open tag, on second one\n                // indentation will be removed with open tag\n                let line = start.line + 2;\n                const baseIndent = getLineIndent(editor, open[0]);\n                const innerIndent = getLineIndent(editor, innerRange[0]);\n\n                while (line <= end.line) {\n                    const lineStart = editor.indexFromPos({ line, ch: 0 });\n                    const indentRange: TextRange = [lineStart, lineStart + innerIndent.length];\n                    if (isSpaceText(substr(editor, indentRange))) {\n                        console.log('replace \"%s\" with \"%s\"', substr(editor, indentRange), baseIndent);\n                        replaceWithSnippet(editor, indentRange, baseIndent);\n                    }\n                    line++;\n                }\n            }\n\n            replaceWithSnippet(editor, [open[0], innerRange[0]], '');\n        } else {\n            replaceWithSnippet(editor, [open[0], close[1]], '');\n        }\n    } else {\n        replaceWithSnippet(editor, open, '');\n    }\n}\n\n/**\n * Returns indentation for line found from given character location\n */\nfunction getLineIndent(editor: CodeMirror.Editor, ix: number): string {\n    return lineIndent(editor, editor.posFromIndex(ix).line);\n}\n\n","import { TextRange } from '@emmetio/action-utils';\nimport { isCSS, isHTML, docSyntax } from '../lib/syntax';\nimport { getContent, toRange, textRange, rangesEqual, rangeContains } from '../lib/utils';\nimport { selectItem } from '../lib/emmet';\n\nexport default function selectItemCommand(editor: CodeMirror.Editor, isPrev = false) {\n    const syntax = docSyntax(editor);\n\n    if (!isCSS(syntax) && !isHTML(syntax)) {\n        return;\n    }\n\n    const sel = editor.listSelections()[0];\n    const selRange = textRange(editor, sel);\n    const code = getContent(editor);\n    let model = selectItem(code, selRange[0], isCSS(syntax), isPrev);\n\n    if (model) {\n        let range = findRange(selRange, model.ranges, isPrev);\n        if (!range) {\n            // Out of available selection range, move to next item\n            const nextPos = isPrev ? model.start : model.end;\n            model = selectItem(code, nextPos, isCSS(syntax), isPrev);\n            if (model) {\n                range = findRange(selRange, model.ranges, isPrev)\n            }\n        }\n\n        if (range) {\n            const [from, to] = toRange(editor, range);\n            editor.setSelection(from, to);\n        }\n    }\n}\n\nfunction findRange(sel: TextRange, ranges: TextRange[], reverse = false) {\n    if (reverse) {\n        ranges = ranges.slice().reverse();\n    }\n\n    let getNext = false;\n    let candidate: TextRange | undefined;\n\n    for (const r of ranges) {\n        if (getNext) {\n            return r;\n        }\n        if (  rangesEqual(r, sel)) {\n            // This range is currently selected, request next\n            getNext = true;\n        } else if (!candidate && (rangeContains(r, sel) || (reverse && r[0] <= sel[0]) || (!reverse && r[0] >= sel[0]))) {\n            candidate = r;\n        }\n    }\n\n    if (!getNext) {\n        return candidate;\n    }\n}\n","import { isXML, syntaxInfo } from '../lib/syntax';\nimport { getTagContext } from '../lib/emmet';\nimport { isSpace, substr, replaceWithSnippet, CMRange } from '../lib/utils';\n\nexport default function splitJoinTag(editor: CodeMirror.Editor) {\n    const selections = editor.listSelections().slice().reverse();\n    const nextRanges: CMRange[] = [];\n\n    editor.operation(() => {\n        for (const sel of selections) {\n            const pos = editor.indexFromPos(sel.anchor);\n            const { syntax } = syntaxInfo(editor, pos);\n            const tag = getTagContext(editor, pos, isXML(syntax));\n\n            if (tag) {\n                const { open, close } = tag;\n                if (close) {\n                    // Join tag: remove tag contents, if any, and add closing slash\n                    replaceWithSnippet(editor, [open[1], close[1]], '');\n                    let closing = isSpace(getChar(editor, open[1] - 2)) ? '/' : ' /';\n                    replaceWithSnippet(editor, [open[1] - 1, open[1] - 1], closing);\n                    nextRanges.push(createRange(editor, open[1] + closing.length));\n                } else {\n                    // Split tag: add closing part and remove closing slash\n                    const endTag = `</${tag.name}>`;\n\n                    replaceWithSnippet(editor, [open[1], open[1]], endTag);\n                    if (getChar(editor, open[1] - 2) === '/') {\n                        let start = open[1] - 2;\n                        let end = open[1] - 1;\n                        if (isSpace(getChar(editor, start - 1))) {\n                            start--;\n                        }\n\n                        replaceWithSnippet(editor, [start, end], '');\n                        nextRanges.push(createRange(editor, open[1] - end + start));\n                    } else {\n                        nextRanges.push(createRange(editor, open[1]));\n                    }\n                }\n            } else {\n                nextRanges.push(sel);\n            }\n        }\n        editor.setSelections(nextRanges);\n    });\n}\n\nfunction getChar(editor: CodeMirror.Editor, pos: number): string {\n    return substr(editor, [pos, pos + 1]);\n}\n\nfunction createRange(editor: CodeMirror.Editor, pos: number): CMRange {\n    const p = editor.posFromIndex(pos);\n    return {\n        anchor: p,\n        head: p\n    };\n}\n","import { UserConfig } from 'emmet';\nimport { parse as parseMarkup, tokenize as tokenizeMarkup, MarkupAbbreviation } from '@emmetio/abbreviation';\nimport { parser as parseStylesheet, tokenize as tokenizeStylesheet, CSSAbbreviation } from '@emmetio/css-abbreviation';\nimport CodeMirror from 'codemirror';\nimport getEmmetConfig, { defaultConfig, EmmetConfig, EmmetEditorOptions } from './lib/config';\n\nimport abbreviationTracker, { extractTracker, allowTracking, getCompletion, restoreOnUndo } from './abbreviation';\n\n// import { extractTracker, allowTracking } from './abbreviation';\n// import { startTracking } from './abbreviation/AbbreviationTracker';\n\nimport matchTags from './lib/match-tags';\nimport markupMode from './mode/markup';\nimport stylesheetMode from './mode/stylesheet';\nimport snippetMode from './mode/snippet';\n\nimport expandAbbreviation from './commands/expand-abbreviation';\nimport emmetResetAbbreviation from './commands/reset-abbreviation'\nimport emmetCaptureAbbreviation from './commands/capture-abbreviation'\nimport emmetEnterAbbreviationMode from './commands/enter-abbreviation';\nimport emmetInsertLineBreak from './commands/insert-line-break';\nimport emmetWrapWithAbbreviation from './commands/wrap-with-abbreviation';\nimport emmetBalance from './commands/balance';\nimport emmetToggleComment from './commands/comment';\nimport emmetEvaluateMath from './commands/evaluate-math';\nimport goToEditPoint from './commands/go-to-edit-point';\nimport emmetGoToTagPair from './commands/go-to-tag-pair';\nimport incrementNumber from './commands/inc-dec-number';\nimport emmetRemoveTag from './commands/remove-tag';\nimport selectItem from './commands/select-item';\nimport emmetSplitJoinTag from './commands/split-join-tag';\nimport { expand, getOptions } from './lib/emmet';\nimport { getInternalState, hasInternalState } from './lib/utils';\n\nexport interface EmmetEditor extends CodeMirror.Editor {\n    /**\n     * Expands given abbreviation with options, defined for current editor\n     */\n    expandAbbreviation(abbr: string, options?: UserConfig): string;\n    /**\n     * Returns Emmet config for given location in editor\n     */\n    emmetOptions(pos?: number, withContext?: boolean): UserConfig;\n\n    /** Parses given abbreviation to AST or throws exception if abbreviation is invalid */\n    parseAbbreviation(abbr: string, type: 'markup' | 'jsx'): MarkupAbbreviation;\n    parseAbbreviation(abbr: string, type: 'stylesheet'): CSSAbbreviation;\n    getEmmetCompletion(pos: number | CodeMirror.Position): CompletionItem;\n}\n\ninterface CompletionItem {\n    text: string;\n    displayText: string;\n    hint(): void;\n    from: CodeMirror.Position;\n    to: CodeMirror.Position;\n}\n\n/**\n * Registers Emmet extension on given CodeMirror constructor.\n * This file is designed to be imported somehow into the app (CommonJS, ES6,\n * Rollup/Webpack/whatever). If you simply want to add a <script> into your page\n * that registers Emmet extension on global CodeMirror constructor, use\n * `browser.js` instead\n */\nexport default function registerEmmetExtension(CM: typeof CodeMirror) {\n    // Register Emmet commands\n    Object.assign(CM.commands, {\n        emmetExpandAbbreviation: (editor: CodeMirror.Editor) => expandAbbreviation(editor, true),\n        emmetExpandAbbreviationAll: (editor: CodeMirror.Editor) => expandAbbreviation(editor, false),\n        emmetCaptureAbbreviation,\n        emmetResetAbbreviation,\n        emmetEnterAbbreviationMode,\n        emmetInsertLineBreak,\n        emmetWrapWithAbbreviation,\n        emmetBalance,\n        emmetBalanceInward: (editor: CodeMirror.Editor) => emmetBalance(editor, true),\n        emmetToggleComment,\n        emmetEvaluateMath,\n        emmetGoToNextEditPoint: (editor: CodeMirror.Editor) => goToEditPoint(editor, 1),\n        emmetGoToPreviousEditPoint: (editor: CodeMirror.Editor) => goToEditPoint(editor, -1),\n        emmetGoToTagPair,\n        emmetIncrementNumber1: (editor: CodeMirror.Editor) => incrementNumber(editor, 1),\n        emmetIncrementNumber01: (editor: CodeMirror.Editor) => incrementNumber(editor, .1),\n        emmetIncrementNumber10: (editor: CodeMirror.Editor) => incrementNumber(editor, 10),\n        emmetDecrementNumber1: (editor: CodeMirror.Editor) => incrementNumber(editor, -1),\n        emmetDecrementNumber01: (editor: CodeMirror.Editor) => incrementNumber(editor, -.1),\n        emmetDecrementNumber10: (editor: CodeMirror.Editor) => incrementNumber(editor, -10),\n        emmetRemoveTag,\n        emmetSelectNextItem: (editor: CodeMirror.Editor) => selectItem(editor),\n        emmetSelectPreviousItem: (editor: CodeMirror.Editor) => selectItem(editor, true),\n        emmetSplitJoinTag,\n    });\n\n    // Track options change\n    CM.defineOption('emmet', defaultConfig, (editor: CodeMirror.Editor, value: EmmetConfig) => {\n        if (!hasInternalState(editor)) {\n            editor.on('change', undoTracker);\n            editor.on('change', pasteTracker);\n        }\n\n        const state = getInternalState(editor);\n        value = getEmmetConfig(editor, value);\n\n        if (value.mark && !state.tracker) {\n            state.tracker = abbreviationTracker(editor);\n        } else if (!value.mark && state.tracker) {\n            state.tracker();\n            state.tracker = null;\n        }\n\n        if (value.markTagPairs && !state.tagMatch) {\n            state.tagMatch = matchTags(editor);\n        } else if (!value.markTagPairs && state.tagMatch) {\n            state.tagMatch();\n            state.tagMatch = null;\n        }\n    });\n\n    CM.defineMode('emmet-abbreviation', markupMode);\n    CM.defineMode('emmet-css-abbreviation', stylesheetMode);\n    CM.defineMode('emmet-snippet', snippetMode);\n\n    // Expose `expandAbbreviation` method to all instances to allow\n    // programmatic usage based on current Emmet options\n    CM.defineExtension('expandAbbreviation', function (this: CodeMirror.Editor, abbr: string, options = getOptions(this, 0)) {\n        return expand(this, abbr, options);\n    });\n\n    CM.defineExtension('emmetOptions', function (this: CodeMirror.Editor, pos = 0) {\n        return getOptions(this, pos);\n    });\n\n    CM.defineExtension('parseAbbreviation', function (this: CodeMirror.Editor, abbr: string, type: 'markup' | 'stylesheet' | 'jsx') {\n        if (type === 'stylesheet') {\n            return parseStylesheet(tokenizeStylesheet(abbr));\n        } else {\n            return parseMarkup(tokenizeMarkup(abbr), { jsx: type === 'jsx' });\n        }\n    });\n\n    CM.defineExtension('getEmmetCompletion', function (this: CodeMirror.Editor, pos: number | CodeMirror.Position) {\n        if (typeof pos !== 'number') {\n            pos = this.indexFromPos(pos);\n        }\n\n        return getCompletion(this, pos);\n    });\n}\n\n/**\n * Undo tracker, if possible\n */\nfunction undoTracker(editor: CodeMirror.Editor, change: CodeMirror.EditorChangeLinkedList) {\n    if (change.origin === 'undo' && change.text.length === 1) {\n        const pos = editor.indexFromPos(change.from);\n        const abbr = change.text[0];\n        restoreOnUndo(editor, pos, abbr);\n    }\n}\n\n/**\n * Capture abbreviation on paste, if possible\n */\nfunction pasteTracker(editor: CodeMirror.Editor, change: CodeMirror.EditorChangeLinkedList) {\n    if (change.origin === 'paste' && change.text.length === 1 && allowTracking(editor, editor.indexFromPos(change.from))) {\n        // Try to capture abbreviation on paste\n        const pos = editor.indexFromPos(change.from) + change.text[0].length;\n        extractTracker(editor, pos);\n    }\n}\n\nexport { EmmetConfig, EmmetEditorOptions };\n","import registerEmmetExtension from './extension';\n\nif (typeof window.CodeMirror !== 'undefined') {\n    registerEmmetExtension(window.CodeMirror);\n}\n"],"names":["isWhiteSpace","isQuote","isQuote$1","tokenize","getToken","operator","field","bracket","whiteSpace","literal","consumePlaceholder","isLiteral","createLiteral","isBracket","operatorType","last","tokenScanner","peek","readable","consume","error","isSiblingOperator","isLiteral$1","isOpenBracket","isBracket$1","isOperator","scan","comment","operators","match","balancedOutward","balancedInward","parse$2","push","stringifyValue","isField","element","element$1","parse","stringify","opt","parse$3","parse$1","defaultOptions","defaultConfig","peek$1","isCloseBracket","isAlpha","isNumber","defaultOptions$1","consumeArray","isSpace","attributeValue","isSelfClose","stylesheetAbbreviation","markupAbbreviation","expand","pairs","isQuoted","isQuotedString","isExprString","getEmbeddedStyleSyntax","getMarkupAbbreviationContext","getStylesheetAbbreviationContext","consumeNumber","extract","cssBalancedInward","cssBalancedOutward","extractMath","unquoted","emmetAbbreviationMode","getTokenName","ident","expandAbbreviation","getContent","pushRange","matchCSS","allocTag","releaseTag","isSpaceText","emmetCaptureAbbreviation","emmetResetAbbreviation","emmetEnterAbbreviationMode","emmetInsertLineBreak","emmetWrapWithAbbreviation","emmetBalance","emmetToggleComment","emmetEvaluateMath","emmetGoToTagPair","emmetRemoveTag","selectItem","emmetSplitJoinTag","abbreviationTracker","matchTags","markupMode","stylesheetMode","snippetMode","parseStylesheet","tokenizeStylesheet","parseMarkup","tokenizeMarkup"],"mappings":"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"}